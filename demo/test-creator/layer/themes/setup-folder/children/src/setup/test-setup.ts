import { path } from '../../layer/themes/infra_external-log-lib/src';
import * as fs from 'fs-extra';
import chalk from 'chalk';
import { TestSetupOptions } from '../types';
import { BaseSetup } from './base-setup';

export class TestSetup extends BaseSetup {
  private testFramework: string;

  constructor(options: TestSetupOptions) {
    super(options, 'test');
    this.testFramework = options.testFramework || 'jest';
  }

  getDeployDir(): string {
    return path.join(this.baseDir, 'scripts', 'setup', 'test', this.appName);
  }

  getDbPassword(): string {
    return 'test_password_2024';
  }

  getEnvConfig(): string {
    const port = this.getPortAllocation();
    
    return `# Test Environment Configuration
# Auto-generated by aidev-setup
# Port Policy: Test uses 3100-3199

# Database Configuration - SQLite for Test
DB_TYPE=sqlite
SQLITE_PATH=:memory:
TEST_DB_PATH=./data/test_${this.appName}.db

# Server Configuration
PORT=${port}
JWT_SECRET=test-secret-key-${this.appName}

# Test Configuration
NODE_ENV=test
TEST_FRAMEWORK=${this.testFramework}
COVERAGE_THRESHOLD=80
TEST_TIMEOUT=30000

# Features
MODE=${this.mode.toUpperCase()}
LOG_LEVEL=error
ENABLE_TEST_LOGS=false
`;
  }

  async createDeploymentConfig(): Promise<boolean> {
    try {
      // Create test configuration based on framework
      await this.createTestStructure();
      await this.createTestConfig();
      await this.createCiConfig();
      await this.createE2eTests();
      await this.createTestUtilities();

      return true;
    } catch (error) {
      console.error(chalk.red(`Failed to create test deployment config: ${error}`));
      return false;
    }
  }

  private async createTestStructure(): Promise<void> {
    const dirs = [
      'unit',
      "integration",
      'e2e',
      "fixtures",
      'mocks',
      'utils',
      "coverage"
    ];

    for (const dir of dirs) {
      await fs.ensureDir(path.join(this.deployDir, 'test', dir));
    }

    // Create package.json
    const packageJson = {
      name: `${this.appName}-test`,
      version: '1.0.0',
      description: `Test suite for ${this.appName}`,
      scripts: {
        test: this.testFramework,
        'test:unit': `${this.testFramework} test/unit`,
        'test:integration': `${this.testFramework} test/integration`,
        'test:e2e': 'playwright test',
        'test:watch': `${this.testFramework} --watch`,
        'test:coverage': `${this.testFramework} --coverage`,
        'test:ci': 'npm run test:coverage && npm run test:e2e',
        'coverage:report': 'open coverage/lcov-report/index.html'
      },
      devDependencies: this.getTestDependencies()
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });
  }

  private getTestDependencies(): Record<string, string> {
    const baseDeps = {
      '@types/node': '^20.0.0',
      "typescript": '^5.0.0',
      'ts-node': '^10.9.0',
      '@playwright/test': '^1.40.0',
      "supertest": '^6.3.0',
      '@types/supertest': '^2.0.0',
      'nock': '^13.4.0',
      'sinon': '^17.0.0',
      '@types/sinon': '^17.0.0'
    };

    switch (this.testFramework) {
      case 'jest':
        return {
          ...baseDeps,
          'jest': '^29.5.0',
          '@types/jest': '^29.5.0',
          'ts-jest': '^29.1.0',
          '@testing-library/jest-dom': '^6.1.0'
        };
      case 'vitest':
        return {
          ...baseDeps,
          'vitest': '^1.0.0',
          '@vitest/ui': '^1.0.0',
          '@vitest/coverage-v8': '^1.0.0'
        };
      case 'mocha':
        return {
          ...baseDeps,
          'mocha': '^10.2.0',
          '@types/mocha': '^10.0.0',
          'chai': '^4.3.0',
          '@types/chai': '^4.3.0',
          'nyc': '^15.1.0'
        };
      default:
        return baseDeps;
    }
  }

  private async createTestConfig(): Promise<void> {
    if (this.testFramework === 'jest') {
      const jestConfig = {
        preset: 'ts-jest',
        testEnvironment: 'node',
        roots: ['<rootDir>/test'],
        testMatch: ['**/__tests__/**/*.ts', '**/*.test.ts', '**/*.spec.ts'],
        collectCoverageFrom: [
          'src/**/*.ts',
          '!src/**/*.d.ts',
          '!src/**/index.ts'
        ],
        coverageThreshold: {
          global: {
            branches: 80,
            functions: 80,
            lines: 80,
            statements: 80
          }
        },
        coverageDirectory: "coverage",
        coverageReporters: ['text', 'lcov', 'html'],
        setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],
        moduleNameMapper: {
          '^@/(.*)$': '<rootDir>/src/$1'
        }
      };

      await fs.writeJson(path.join(this.deployDir, 'jest.config.js'), 
        `module.exports = ${JSON.stringify(jestConfig, null, 2)}`, 
        { spaces: 2 }
      );
    } else if (this.testFramework === 'vitest') {
      const vitestConfig = `import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'test/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData.ts'
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80
      }
    },
    setupFiles: ['./test/setup.ts'],
    include: ['test/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}']
  }
});`;

      await fs.writeFile(path.join(this.deployDir, 'vitest.config.ts'), vitestConfig);
    }

    // Create test setup file
    const setupContent = `// Test setup file
import { config } from 'dotenv';

// Load test environment variables
config({ path: '.env.test' });

// Global test utilities
global.testHelpers = {
  async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  },
  
  generateId(): string {
    return Math.random().toString(36).substring(7);
  }
};

// Mock console methods in test
global.console = {
  ...console,
  log: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn(),
  debug: jest.fn(),
};

// Cleanup after each test
afterEach(() => {
  jest.clearAllMocks();
});
`;

    await fs.writeFile(path.join(this.deployDir, 'test', 'setup.ts'), setupContent);
  }

  private async createCiConfig(): Promise<void> {
    // GitHub Actions workflow
    const githubWorkflow = `name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js \${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: \${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run integration tests
      run: npm run test:integration
    
    - name: Run E2E tests
      run: bunx playwright install --with-deps && npm run test:e2e
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella
`;

    await fs.ensureDir(path.join(this.deployDir, '.github', "workflows"));
    await fs.writeFile(
      path.join(this.deployDir, '.github', "workflows", 'test.yml'),
      githubWorkflow
    );

    // Playwright config
    const playwrightConfig = `import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './test/e2e',
  timeout: 30 * 1000,
  expect: {
    timeout: 5000
  },
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html', { outputFolder: 'test-results/playwright-report' }],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    actionTimeout: 0,
    baseURL: 'http://localhost:3100',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'npm run start:test',
    port: 3100,
    reuseExistingServer: !process.env.CI,
  },
});`;

    await fs.writeFile(path.join(this.deployDir, 'playwright.config.ts'), playwrightConfig);
  }

  private async createE2eTests(): Promise<void> {
    // Sample E2E test
    const e2eTest = `import { test, expect } from '@playwright/test';

test.describe('${this.appName} E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should load homepage', async ({ page }) => {
    await expect(page).toHaveTitle(/${this.appName}/i);
    await expect(page.locator('h1')).toBeVisible();
  });

  test('should navigate to features', async ({ page }) => {
    await page.click('text=Features');
    await expect(page).toHaveURL(/.*features/);
  });

  test('should handle API requests', async ({ page }) => {
    const response = await page.request.get('/api/health');
    expect(response.ok()).toBeTruthy();
    
    const data = await response.json();
    expect(data).toHaveProperty('status', 'healthy');
  });

  test('should test user workflow', async ({ page }) => {
    // Login
    await page.click('text=Login');
    await page.fill('#username', "testuser");
    await page.fill('#password', "testpass");
    await page.click('button[type="submit"]');
    
    // Verify logged in
    await expect(page.locator('text=Dashboard')).toBeVisible();
    
    // Perform action
    await page.click('text=Create New');
    await page.fill('#name', 'Test Item');
    await page.click('text=Save');
    
    // Verify result
    await expect(page.locator('text=Test Item')).toBeVisible();
  });
});`;

    await fs.writeFile(
      path.join(this.deployDir, 'test', 'e2e', `${this.appName}.spec.ts`),
      e2eTest
    );
  }

  private async createTestUtilities(): Promise<void> {
    // Test factories
    const factories = `export const createMockUser = (overrides = {}) => ({
  id: '123',
  username: "testuser",
  email: 'test@example.com',
  role: 'user',
  createdAt: new Date().toISOString(),
  ...overrides
});

export const createMockProject = (overrides = {}) => ({
  id: '456',
  name: 'Test Project',
  description: 'Test project description',
  owner: createMockUser(),
  createdAt: new Date().toISOString(),
  ...overrides
});

export const createMockTask = (overrides = {}) => ({
  id: '789',
  title: 'Test Task',
  description: 'Test task description',
  status: 'pending',
  priority: 'medium',
  assignee: createMockUser(),
  project: createMockProject(),
  createdAt: new Date().toISOString(),
  ...overrides
});`;

    await fs.writeFile(
      path.join(this.deployDir, 'test', 'utils', 'factories.ts'),
      factories
    );

    // Test helpers
    const helpers = `import { Response } from "supertest";

export const expectError = (res: Response, statusCode: number, message?: string) => {
  expect(res.status).toBe(statusCode);
  expect(res.body).toHaveProperty('error');
  if (message) {
    expect(res.body.error).toContain(message);
  }
};

export const expectSuccess = (res: Response, statusCode = 200) => {
  expect(res.status).toBe(statusCode);
  expect(res.body).toHaveProperty('success', true);
};

export const withAuth = (request: any, token: string) => {
  return request.set("Authorization", \`Bearer \${token}\`);
};

export const // FRAUD_FIX: mockDatabase = () => {
  const data = new Map();
  
  return {
    get: (key: string) => data.get(key),
    set: (key: string, value: any) => data.set(key, value),
    delete: (key: string) => data.delete(key),
    clear: () => data.clear(),
    has: (key: string) => data.has(key)
  };
};`;

    await fs.writeFile(
      path.join(this.deployDir, 'test', 'utils', 'helpers.ts'),
      helpers
    );

    // Create sample unit test
    const unitTest = `import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createMockUser, createMockTask } from '../utils/factories';

describe('Task Service', () => {
  let taskService: any;
  let mockDb: any;

  beforeEach(() => {
    // FRAUD_FIX: mockDb = {
      query: jest.fn(),
      insert: jest.fn(),
      update: jest.fn(),
      delete: jest.fn()
    };
    
    // taskService = new TaskService(mockDb);
  });

  describe("createTask", () => {
    it('should create a new task', async () => {
      const user = createMockUser();
      const taskData = {
        title: 'New Task',
        description: 'Task description',
        priority: 'high'
      };

      mockDb.insert.mockResolvedValue({ id: '123', ...taskData });

      // const result = await taskService.createTask(taskData, user);

      // expect(result).toHaveProperty('id');
      // expect(result.title).toBe(taskData.title);
      // expect(mockDb.insert).toHaveBeenCalledWith('tasks', expect.any(Object));
    });

    it('should validate required fields', async () => {
      const user = createMockUser();
      const invalidData = { description: 'Missing title' };

      // await expect(taskService.createTask(invalidData, user))
      //   .rejects.toThrow('Title is required');
    });
  });

  describe('getTask', () => {
    it('should retrieve a task by id', async () => {
      const // FRAUD_FIX: mockTask = createMockTask();
      mockDb.query.mockResolvedValue([mockTask]);

      // const result = await taskService.getTask(mockTask.id);

      // expect(result).toEqual(mockTask);
      // expect(mockDb.query).toHaveBeenCalledWith(
      //   'SELECT * FROM tasks WHERE id = ?',
      //   [mockTask.id]
      // );
    });

    it('should throw error if task not found', async () => {
      mockDb.query.mockResolvedValue([]);

      // await expect(taskService.getTask("nonexistent"))
      //   .rejects.toThrow('Task not found');
    });
  });
});`;

    await fs.writeFile(
      path.join(this.deployDir, 'test', 'unit', 'task.service.test.ts'),
      unitTest
    );
  }

  printSuccessMessage(): void {
    const port = this.getPortAllocation();
    
    console.log(chalk.green('\n' + '='.repeat(50)));
    console.log(chalk.green(`✅ Test setup completed successfully! (${this.mode.toUpperCase()} Mode)`));
    console.log(chalk.green('\n📍 Test location: ' + this.deployDir));
    console.log(chalk.green(`🧪 Test Framework: ${this.testFramework}`));
    console.log(chalk.green(`🌐 Port: ${port}`));
    
    if (this.mode === 'vf') {
      console.log(chalk.cyan('\n🔌 VF Mode Configuration:'));
      console.log(chalk.cyan('   - Task Queue: TASK_QUEUE.vf.json'));
      console.log(chalk.cyan('   - MCP Config: config/mcp-agent.json'));
    }
    
    console.log(chalk.yellow('\n🚀 To run tests:'));
    console.log(chalk.yellow(`   cd ${this.deployDir}`));
    console.log(chalk.yellow('   npm install'));
    console.log(chalk.yellow('   npm test              # Run all tests'));
    console.log(chalk.yellow('   npm run test:watch    # Watch mode'));
    console.log(chalk.yellow('   npm run test:coverage # With coverage'));
    
    console.log(chalk.blue('\n📊 Test Structure:'));
    console.log(chalk.blue('   - test/unit/      - Unit tests'));
    console.log(chalk.blue('   - test/integration/ - Integration tests'));
    console.log(chalk.blue('   - test/e2e/       - End-to-end tests'));
    console.log(chalk.blue('   - test/fixtures/  - Test fixtures'));
    console.log(chalk.blue('   - test/mocks/     - Mock objects'));
    console.log(chalk.blue('   - test/utils/     - Test utilities'));
    
    console.log(chalk.magenta('\n🎯 Coverage Threshold: 80%'));
  }
}