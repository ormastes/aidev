import { test, expect } from '@playwright/test';

/**
 * Authentication Flow Test Template
 * Generated by Explorer QA Agent
 */

test.describe('Authentication Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Set up console error monitoring
    page.on('console', msg => {
      if (msg.type() === 'error') {
        console.error(`Console error: ${msg.text()}`);
      }
    });

    // Navigate to the application
    await page.goto(process.env.STAGING_URL || 'https://staging.example.com');
  });

  test('should login successfully with valid credentials', async ({ page }) => {
    // Track console errors
    const consoleErrors: string[] = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
      }
    });

    // Navigate to login
    await page.getByRole('link', { name: /login|sign in/i }).click();

    // Fill credentials
    await page.getByLabel(/email|username/i).fill('{{TEST_EMAIL}}');
    await page.getByLabel(/password/i).fill('{{TEST_PASSWORD}}');

    // Submit form
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();

    // Verify successful login
    await expect(page).toHaveURL(/dashboard|home|profile/);
    
    // Check for errors
    expect(consoleErrors).toHaveLength(0);
  });

  test('should show error for invalid credentials', async ({ page }) => {
    // Navigate to login
    await page.getByRole('link', { name: /login|sign in/i }).click();

    // Fill invalid credentials
    await page.getByLabel(/email|username/i).fill('invalid@example.com');
    await page.getByLabel(/password/i).fill('wrongpassword');

    // Submit form
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();

    // Verify error message
    await expect(page.getByText(/invalid|incorrect|wrong/i)).toBeVisible();
    
    // Should not navigate away from login
    await expect(page).toHaveURL(/login|signin|auth/);
  });

  test('should logout successfully', async ({ page }) => {
    // First login
    await page.getByRole('link', { name: /login|sign in/i }).click();
    await page.getByLabel(/email|username/i).fill('{{TEST_EMAIL}}');
    await page.getByLabel(/password/i).fill('{{TEST_PASSWORD}}');
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();
    
    // Wait for dashboard
    await page.waitForURL(/dashboard|home|profile/);

    // Logout
    await page.getByRole('button', { name: /logout|sign out/i }).click();

    // Verify logged out
    await expect(page).toHaveURL(/login|home|\//);
    
    // Verify protected route redirects
    await page.goto(`${process.env.STAGING_URL}/dashboard`);
    await expect(page).toHaveURL(/login|signin|auth/);
  });

  test('should handle session timeout gracefully', async ({ page }) => {
    // Login
    await page.getByRole('link', { name: /login|sign in/i }).click();
    await page.getByLabel(/email|username/i).fill('{{TEST_EMAIL}}');
    await page.getByLabel(/password/i).fill('{{TEST_PASSWORD}}');
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();
    
    // Wait for dashboard
    await page.waitForURL(/dashboard|home|profile/);

    // Simulate session timeout by clearing cookies
    await page.context().clearCookies();

    // Try to navigate to protected page
    await page.reload();

    // Should redirect to login
    await expect(page).toHaveURL(/login|signin|auth/);
  });

  test('should prevent XSS in login form', async ({ page }) => {
    await page.getByRole('link', { name: /login|sign in/i }).click();

    // Try XSS payload
    const xssPayload = '<script>alert("XSS")</script>';
    await page.getByLabel(/email|username/i).fill(xssPayload);
    await page.getByLabel(/password/i).fill(xssPayload);
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();

    // Check that script is not executed
    const alerts: string[] = [];
    page.on('dialog', async dialog => {
      alerts.push(dialog.message());
      await dialog.dismiss();
    });

    // Wait a bit for any potential XSS
    await page.waitForTimeout(1000);

    // No alerts should have been triggered
    expect(alerts).toHaveLength(0);
  });

  test('should enforce rate limiting on login attempts', async ({ page }) => {
    await page.getByRole('link', { name: /login|sign in/i }).click();

    // Make multiple rapid login attempts
    for (let i = 0; i < 10; i++) {
      await page.getByLabel(/email|username/i).fill(`attempt${i}@example.com`);
      await page.getByLabel(/password/i).fill('wrongpassword');
      await page.getByRole('button', { name: /login|sign in|submit/i }).click();
      
      // Small delay between attempts
      await page.waitForTimeout(100);
    }

    // Should show rate limit error or temporarily block
    const errorText = await page.textContent('body');
    expect(errorText).toMatch(/rate limit|too many|try again/i);
  });
});

test.describe('Authentication Security', () => {
  test('should not expose passwords in network requests', async ({ page }) => {
    const requests: any[] = [];
    
    page.on('request', request => {
      requests.push({
        url: request.url(),
        method: request.method(),
        postData: request.postData()
      });
    });

    await page.goto(process.env.STAGING_URL || 'https://staging.example.com');
    await page.getByRole('link', { name: /login|sign in/i }).click();
    
    await page.getByLabel(/email|username/i).fill('{{TEST_EMAIL}}');
    await page.getByLabel(/password/i).fill('{{TEST_PASSWORD}}');
    await page.getByRole('button', { name: /login|sign in|submit/i }).click();

    // Check that password is not in GET requests
    const getRequests = requests.filter(r => r.method === 'GET');
    for (const req of getRequests) {
      expect(req.url).not.toContain('{{TEST_PASSWORD}}');
    }
  });

  test('should have secure headers on auth endpoints', async ({ page }) => {
    const response = await page.goto(`${process.env.STAGING_URL}/login`);
    
    if (response) {
      const headers = response.headers();
      
      // Check security headers
      expect(headers['x-frame-options']).toBeTruthy();
      expect(headers['x-content-type-options']).toBe('nosniff');
      expect(headers['strict-transport-security']).toBeTruthy();
    }
  });
});