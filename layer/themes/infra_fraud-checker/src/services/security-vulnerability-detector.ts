import { auditedFS } from '../../../infra_external-log-lib/pipe';
import { path } from '../../../infra_external-log-lib/src';
import { glob } from 'glob';

interface SecurityVulnerabilityResult {
  totalVulnerabilities: number;
  criticalVulnerabilities: number;
  violations: SecurityViolation[];
}

interface SecurityViolation {
  file: string;
  line: number;
  type: string;
  description: string;
  severity: "critical" | 'high' | 'medium' | 'low';
  cwe?: string; // Common Weakness Enumeration
}

export class SecurityVulnerabilityDetector {
  async analyze(targetPath: string, mode: string): Promise<SecurityVulnerabilityResult> {
    const sourceFiles = await this.findSourceFiles(targetPath, mode);
    const violations: SecurityViolation[] = [];
    let totalVulnerabilities = 0;
    let criticalVulnerabilities = 0;

    for (const file of sourceFiles) {
      const fileViolations = await this.analyzeFile(file, targetPath);
      violations.push(...fileViolations);
      totalVulnerabilities += fileViolations.length;
      criticalVulnerabilities += fileViolations.filter(v => v.severity === "critical").length;
    }

    return { totalVulnerabilities, criticalVulnerabilities, violations };
  }

  private async findSourceFiles(targetPath: string, mode: string): Promise<string[]> {
    const patterns = [
      path.join(targetPath, '**/*.ts'),
      path.join(targetPath, '**/*.js'),
      path.join(targetPath, '**/*.tsx'),
      path.join(targetPath, '**/*.jsx')
    ];

    const files: string[] = [];
    for (const pattern of patterns) {
      const matches = await glob(pattern, { 
        ignore: ['**/node_modules/**', '**/dist/**', '**/coverage/**'] 
      });
      files.push(...matches);
    }
    return files;
  }

  private async analyzeFile(filePath: string, basePath: string): Promise<SecurityViolation[]> {
    const content = await auditedFS.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    const violations: SecurityViolation[] = [];
    const relativePath = path.relative(basePath, filePath);

    lines.forEach((line, index) => {
      const lineNum = index + 1;

      // SQL Injection vulnerabilities
      if (this.hasSQLInjection(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'sql-injection',
          description: 'Potential SQL injection vulnerability',
          severity: "critical",
          cwe: 'CWE-89'
        });
      }

      // XSS vulnerabilities
      if (this.hasXSS(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'xss',
          description: 'Potential XSS vulnerability',
          severity: 'high',
          cwe: 'CWE-79'
        });
      }

      // Hardcoded secrets
      if (this.hasHardcodedSecret(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'hardcoded-secret',
          description: 'Hardcoded secret detected',
          severity: "critical",
          cwe: 'CWE-798'
        });
      }

      // Insecure random
      if (this.hasInsecureRandom(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'insecure-random',
          description: 'Using Math.random() for security-sensitive operations',
          severity: 'medium',
          cwe: 'CWE-330'
        });
      }

      // Command injection
      if (this.hasCommandInjection(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'command-injection',
          description: 'Potential command injection vulnerability',
          severity: "critical",
          cwe: 'CWE-78'
        });
      }

      // Path traversal
      if (this.hasPathTraversal(line)) {
        violations.push({
          file: relativePath,
          line: lineNum,
          type: 'path-traversal',
          description: 'Potential path traversal vulnerability',
          severity: 'high',
          cwe: 'CWE-22'
        });
      }
    });

    return violations;
  }

  private hasSQLInjection(line: string): boolean {
    const patterns = [
      /query\s*\(\s*['"`].*\+/,
      /query\s*\(\s*`.*\${/,
      /execute\s*\(\s*['"`].*\+/,
      /raw\s*\(\s*['"`].*\+/
    ];

    return patterns.some(pattern => pattern.test(line));
  }

  private hasXSS(line: string): boolean {
    const patterns = [
      /innerHTML\s*=.*\+/,
      /dangerouslySetInnerHTML/,
      /document\.write\s*\(/,
      /eval\s*\(/
    ];

    return patterns.some(pattern => pattern.test(line));
  }

  private hasHardcodedSecret(line: string): boolean {
    const patterns = [
      /apiKey\s*[:=]\s*["'][a-zA-Z0-9]{20,}/,
      /secret\s*[:=]\s*["'][a-zA-Z0-9]{20,}/,
      /password\s*[:=]\s*["'](?!test|password|123456)[^"']{8,}/,
      /token\s*[:=]\s*["'][a-zA-Z0-9]{30,}/,
      /private_key\s*[:=]/i
    ];

    return patterns.some(pattern => pattern.test(line));
  }

  private hasInsecureRandom(line: string): boolean {
    return /Math\.random\s*\(\)/.test(line) && 
           (line.includes('token') || line.includes("password") || line.includes('secret'));
  }

  private hasCommandInjection(line: string): boolean {
    const patterns = [
      /exec\s*\(.*\+/,
      /execSync\s*\(.*\+/,
      /spawn\s*\(.*\+/,
      /system\s*\(.*\+/
    ];

    return patterns.some(pattern => pattern.test(line));
  }

  private hasPathTraversal(line: string): boolean {
    const patterns = [
      /readFile.*\+/,
      /writeFile.*\+/,
      /createReadStream.*\+/,
      /\.\.\/\.\./
    ];

    return patterns.some(pattern => pattern.test(line));
  }
}