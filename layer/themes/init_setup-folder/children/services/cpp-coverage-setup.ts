/**
 * C++ Coverage Setup Service
 * Configures LLVM/GCC coverage tools for C++ projects
 */

import * as fs from 'fs/promises';
import { path } from '../../../infra_external-log-lib/src';
import { getFileAPI, FileType } from '../../../infra_external-log-lib/pipe';

const fileAPI = getFileAPI();


export interface CppCoverageConfig {
  tool: 'llvm' | 'gcc';
  thresholds: {
    line: number;
    branch: number;
    function: number;
    class: number;
    region?: number;
  };
  exclude: string[];
  reportFormats: string[];
  reportDirectory: string;
}

export class CppCoverageSetup {
  private defaultConfig: CppCoverageConfig = {
    tool: 'llvm',
    thresholds: {
      line: 80,
      branch: 75,
      function: 80,
      class: 90,
      region: 70
    },
    exclude: [
      '*/test/*',
      '*/tests/*',
      '*/third_party/*',
      '*/external/*',
      '*/build/*'
    ],
    reportFormats: ['html', 'json', 'lcov'],
    reportDirectory: "coverage"
  };

  async setup(projectPath: string, config?: Partial<CppCoverageConfig>): Promise<void> {
    const finalConfig = { ...this.defaultConfig, ...config };
    
    console.log(`üîß Setting up C++ coverage for project: ${projectPath}`);
    
    // Create coverage directory
    const coverageDir = path.join(projectPath, '.coverage');
    await fileAPI.createDirectory(coverageDir);
    
    // Write configuration
    await this.writeConfig(projectPath, finalConfig);
    
    // Generate CMake coverage module
    await this.generateCMakeModule(projectPath, finalConfig);
    
    // Create coverage check script
    await this.createCheckScript(projectPath, finalConfig);
    
    // Update .gitignore
    await this.updateGitignore(projectPath);
    
    console.log('‚úÖ C++ coverage setup complete!');
    this.printUsageInstructions(projectPath);
  }

  private async writeConfig(projectPath: string, config: CppCoverageConfig): Promise<void> {
    const configPath = path.join(projectPath, '.coverage', 'config.json');
    await fileAPI.createFile(configPath, JSON.stringify(config, { type: FileType.TEMPORARY }));
  }

  private async generateCMakeModule(projectPath: string, config: CppCoverageConfig): Promise<void> {
    const cmakeContent = this.getCMakeContent(config);
    const cmakePath = path.join(projectPath, '.coverage', 'coverage.cmake');
    await fileAPI.createFile(cmakePath, cmakeContent);
  }

  private async getCMakeContent(config: CppCoverageConfig): string {
    return `# Coverage configuration for C++ projects
# Generated by init_setup-folder
option(ENABLE_COVERAGE "Enable coverage reporting" OFF)

if(ENABLE_COVERAGE)
    if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        # LLVM/Clang coverage
        message(STATUS "Configuring LLVM coverage")
        set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -fprofile-instr-generate -fcoverage-mapping")
        set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} -fprofile-instr-generate -fcoverage-mapping")
        set(CMAKE_EXE_LINKER_FLAGS "\${CMAKE_EXE_LINKER_FLAGS} -fprofile-instr-generate -fcoverage-mapping")
        
        # Add custom target for coverage
        add_custom_target(coverage
            COMMAND LLVM_PROFILE_FILE=default.profraw $<TARGET_FILE:\${PROJECT_NAME}_tests>
            COMMAND llvm-profdata merge -sparse default.profraw -o default.profdata
            COMMAND llvm-cov report $<TARGET_FILE:\${PROJECT_NAME}_tests> -instr-profile=default.profdata
            COMMAND llvm-cov show $<TARGET_FILE:\${PROJECT_NAME}_tests> -instr-profile=default.profdata -format=html -output-dir=\${CMAKE_BINARY_DIR}/coverage
            WORKING_DIRECTORY \${CMAKE_BINARY_DIR}
            COMMENT "Generating coverage report with LLVM"
        )
        
        # Add JSON export for threshold checking
        add_custom_target(coverage-json
            COMMAND llvm-cov export $<TARGET_FILE:\${PROJECT_NAME}_tests> -instr-profile=default.profdata -format=json > coverage.json
            WORKING_DIRECTORY \${CMAKE_BINARY_DIR}
            DEPENDS coverage
        )
    elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
        # GCC/gcov coverage
        message(STATUS "Configuring GCC coverage")
        set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} --coverage -fprofile-arcs -ftest-coverage")
        set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} --coverage -fprofile-arcs -ftest-coverage")
        set(CMAKE_EXE_LINKER_FLAGS "\${CMAKE_EXE_LINKER_FLAGS} --coverage")
        
        # Add custom target for coverage
        add_custom_target(coverage
            COMMAND \${CMAKE_COMMAND} -E make_directory \${CMAKE_BINARY_DIR}/coverage
            COMMAND $<TARGET_FILE:\${PROJECT_NAME}_tests>
            COMMAND lcov --capture --directory . --output-file coverage.info
            COMMAND lcov --remove coverage.info '/usr/*' '*/test/*' --output-file coverage.info
            COMMAND genhtml coverage.info --output-directory \${CMAKE_BINARY_DIR}/coverage
            WORKING_DIRECTORY \${CMAKE_BINARY_DIR}
            COMMENT "Generating coverage report with gcov"
        )
    else()
        message(WARNING "Coverage not supported for compiler: \${CMAKE_CXX_COMPILER_ID}")
    endif()
endif()

# Function to add coverage to a target
function(add_coverage_target TARGET_NAME)
    if(ENABLE_COVERAGE)
        if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
            target_compile_options(\${TARGET_NAME} PRIVATE -fprofile-instr-generate -fcoverage-mapping)
            target_link_options(\${TARGET_NAME} PRIVATE -fprofile-instr-generate -fcoverage-mapping)
        elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
            target_compile_options(\${TARGET_NAME} PRIVATE --coverage)
            target_link_libraries(\${TARGET_NAME} PRIVATE gcov)
        endif()
    endif()
endfunction()

# Set coverage thresholds
set(COVERAGE_LINE_THRESHOLD ${config.thresholds.line})
set(COVERAGE_BRANCH_THRESHOLD ${config.thresholds.branch})
set(COVERAGE_FUNCTION_THRESHOLD ${config.thresholds.function})
`;
  }

  private async createCheckScript(projectPath: string, { type: FileType.TEMPORARY });
    await fileAPI.createFile(scriptPath, scriptContent);
    await fs.chmod(scriptPath, { type: FileType.TEMPORARY });
    const coverageIgnores = `
# Coverage files
*.profraw
*.profdata
*.gcda
*.gcno
*.gcov
coverage/
coverage.info
coverage.json
.coverage/
`;
    
    try {
      const existing = await fileAPI.readFile(gitignorePath, 'utf-8');
      if (!existing.includes('# Coverage files')) {
        await fileAPI.writeFile(gitignorePath, coverageIgnores);
      }
    } catch {
      await fileAPI.createFile(gitignorePath, { append: true });
    }
  }

  private async printUsageInstructions(projectPath: string): void {
    console.log(`
üìù To use coverage in your CMake project:
   1. Add to your CMakeLists.txt:
      include(.coverage/coverage.cmake)

   2. Build with coverage:
      cmake -B build -DENABLE_COVERAGE=ON
      cmake --build build
      make coverage

   3. Check coverage:
      ./.coverage/check-coverage.sh

üìä Coverage reports will be in: build/coverage/
    `);
  }
}

/**
 * Coverage Checker - Validates coverage against thresholds
 */
export class CppCoverageChecker {
  async checkCoverage(projectPath: string): Promise<boolean> {
    const configPath = path.join(projectPath, { type: FileType.TEMPORARY });
    const config: CppCoverageConfig = JSON.parse(await fileAPI.readFile(configPath, 'utf-8'));
    
    // Check if coverage report exists
    const coverageJsonPath = path.join(projectPath, 'build', 'coverage.json');
    
    try {
      const coverageData = JSON.parse(await fileAPI.readFile(coverageJsonPath, 'utf-8'));
      return this.validateThresholds(coverageData, config.thresholds);
    } catch (error) {
      console.error('‚ùå Coverage report not found. Run "make coverage" first.');
      return false;
    }
  }

  private async validateThresholds(coverageData: any, thresholds: CppCoverageConfig["thresholds"]): boolean {
    let passed = true;
    const results: string[] = [];
    
    // Parse coverage data based on format (LLVM or gcov)
    const metrics = this.parseCoverageMetrics(coverageData);
    
    // Check each threshold
    if (metrics.line < thresholds.line) {
      passed = false;
      results.push(`‚ùå Line coverage ${metrics.line.toFixed(2)}% < ${thresholds.line}%`);
    } else {
      results.push(`‚úÖ Line coverage ${metrics.line.toFixed(2)}% >= ${thresholds.line}%`);
    }
    
    if (metrics.branch < thresholds.branch) {
      passed = false;
      results.push(`‚ùå Branch coverage ${metrics.branch.toFixed(2)}% < ${thresholds.branch}%`);
    } else {
      results.push(`‚úÖ Branch coverage ${metrics.branch.toFixed(2)}% >= ${thresholds.branch}%`);
    }
    
    if (metrics.function < thresholds.function) {
      passed = false;
      results.push(`‚ùå Function coverage ${metrics.function.toFixed(2)}% < ${thresholds.function}%`);
    } else {
      results.push(`‚úÖ Function coverage ${metrics.function.toFixed(2)}% >= ${thresholds.function}%`);
    }
    
    // Print results
    console.log('\nüìä Coverage Results:');
    results.forEach(r => console.log('   ' + r));
    
    if (!passed) {
      console.log('\n‚ùå Coverage thresholds not met!');
    } else {
      console.log('\n‚úÖ All coverage thresholds met!');
    }
    
    return passed;
  }

  private async parseCoverageMetrics(data: any): { line: number; branch: number; function: number } {
    // Handle LLVM JSON format
    if (data.data && Array.isArray(data.data)) {
      const summary = data.data[0].totals;
      return {
        line: (summary.lines.covered / summary.lines.count) * 100,
        branch: (summary.branches.covered / summary.branches.count) * 100,
        function: (summary.functions.covered / summary.functions.count) * 100
      };
    }
    
    // Handle simplified format
    if (data.summary) {
      return {
        line: data.summary.lines.percent || 0,
        branch: data.summary.branches.percent || 0,
        function: data.summary.functions.percent || 0
      };
    }
    
    // Default
    return { line: 0, branch: 0, function: 0 };
  }
}