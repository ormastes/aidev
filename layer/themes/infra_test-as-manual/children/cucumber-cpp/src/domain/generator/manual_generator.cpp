#include "cucumber_cpp/generator/manual_generator.hpp"
#include <fstream>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <algorithm>

namespace cucumber_cpp {
namespace generator {

// ManualTestGenerator implementation
ManualTestGenerator::ManualTestGenerator()
    : author_("Generated by Cucumber-CPP")
    , version_("1.0.0")
    , include_screenshots_(false)
    , include_notes_(true)
    , in_background_(false)
    , in_scenario_(false)
    , in_scenario_outline_(false) {}

std::string ManualTestGenerator::generate(const std::string& featureFile, OutputFormat format) {
    std::ifstream file(featureFile);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open feature file: " + featureFile);
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    
    gherkin::Parser parser(buffer.str());
    auto feature = parser.parse();
    
    if (!feature) {
        throw std::runtime_error("Failed to parse feature file");
    }
    
    return generate(*feature, format);
}

std::string ManualTestGenerator::generate(const gherkin::Feature& feature, OutputFormat format) {
    // Reset state
    current_suite_ = ManualTestSuite();
    current_suite_.name = feature.name();
    current_suite_.description = feature.description();
    current_suite_.version = version_;
    current_suite_.author = author_;
    current_suite_.created_date = getCurrentDate();
    
    // Visit feature to build manual test suite
    feature.accept(*this);
    
    // Format output
    auto formatter = createFormatter(format);
    return formatter->format(current_suite_);
}

void ManualTestGenerator::visitFeature(const gherkin::Feature& feature) {
    // Process background if present
    if (feature.background()) {
        in_background_ = true;
        feature.background()->accept(*this);
        in_background_ = false;
    }
    
    // Process scenarios
    for (const auto& scenario : feature.scenarios()) {
        in_scenario_ = true;
        scenario->accept(*this);
        in_scenario_ = false;
    }
    
    // Process scenario outlines
    for (const auto& outline : feature.scenarioOutlines()) {
        in_scenario_outline_ = true;
        
        // Expand outline into concrete scenarios
        auto expanded = outline->expand();
        for (const auto& scenario : expanded) {
            in_scenario_ = true;
            scenario->accept(*this);
            in_scenario_ = false;
        }
        
        in_scenario_outline_ = false;
    }
}

void ManualTestGenerator::visitBackground(const gherkin::Background& background) {
    background_steps_.clear();
    
    for (const auto& step : background.steps()) {
        std::string stepDesc = enhanceStepDescription(*step);
        background_steps_.push_back(stepDesc);
    }
}

void ManualTestGenerator::visitScenario(const gherkin::Scenario& scenario) {
    current_test_case_ = convertScenario(scenario);
    current_suite_.test_cases.push_back(current_test_case_);
}

void ManualTestGenerator::visitScenarioOutline(const gherkin::ScenarioOutline& outline) {
    // Handled by expanding in visitFeature
}

void ManualTestGenerator::visitStep(const gherkin::Step& step) {
    if (!in_background_) {
        current_steps_.push_back(convertStep(step));
    }
}

void ManualTestGenerator::visitExamples(const gherkin::Examples& examples) {
    // Handled during scenario outline expansion
}

void ManualTestGenerator::visitDataTable(const gherkin::DataTable& table) {
    // Handled in convertStep
}

void ManualTestGenerator::visitDocString(const gherkin::DocString& docString) {
    // Handled in convertStep
}

ManualTestCase ManualTestGenerator::convertScenario(const gherkin::Scenario& scenario) {
    ManualTestCase testCase;
    
    testCase.id = generateTestId(current_suite_.name, scenario.name());
    testCase.name = scenario.name();
    testCase.description = scenario.description();
    testCase.tags = scenario.tags();
    
    // Add background steps as prerequisites
    testCase.prerequisites = background_steps_;
    
    // Convert scenario steps
    current_steps_.clear();
    for (const auto& step : scenario.steps()) {
        testCase.steps.push_back(convertStep(*step));
    }
    
    // Generate expected result from Then steps
    std::stringstream expectedResult;
    for (const auto& step : scenario.steps()) {
        if (step->type() == gherkin::StepType::THEN) {
            if (!expectedResult.str().empty()) {
                expectedResult << "\n";
            }
            expectedResult << "- " << step->text();
        }
    }
    testCase.expected_result = expectedResult.str();
    
    return testCase;
}

ManualTestStep ManualTestGenerator::convertStep(const gherkin::Step& step) {
    ManualTestStep manualStep;
    
    // Convert step to manual action
    manualStep.action = enhanceStepDescription(step);
    manualStep.expected = generateExpectedResult(step);
    
    // Add data if present
    if (step.hasDataTable()) {
        auto dataStrings = convertDataTable(*step.dataTable());
        manualStep.data = dataStrings.empty() ? "" : dataStrings[0];
    }
    
    if (step.hasDocString()) {
        manualStep.data = convertDocString(*step.docString());
    }
    
    // Add notes if enabled
    if (include_notes_) {
        manualStep.notes = generateNotes(step);
    }
    
    return manualStep;
}

std::string ManualTestGenerator::enhanceStepDescription(const gherkin::Step& step) {
    std::string instruction = stepTypeToInstruction(step.type());
    std::string text = step.text();
    
    // Replace parameters with placeholders
    std::regex paramRegex("\"([^\"]+)\"");
    text = std::regex_replace(text, paramRegex, "[$1]");
    
    // Add specific instructions based on keywords
    if (text.find("click") != std::string::npos) {
        text += " (Use mouse to click the element)";
    } else if (text.find("enter") != std::string::npos || text.find("type") != std::string::npos) {
        text += " (Type the value in the field)";
    } else if (text.find("select") != std::string::npos) {
        text += " (Choose from dropdown/list)";
    } else if (text.find("navigate") != std::string::npos || text.find("go to") != std::string::npos) {
        text += " (Open in browser)";
    }
    
    return instruction + " " + text;
}

std::string ManualTestGenerator::generateExpectedResult(const gherkin::Step& step) {
    if (step.type() == gherkin::StepType::THEN) {
        return "Verify: " + step.text();
    }
    return "";
}

std::vector<std::string> ManualTestGenerator::generateNotes(const gherkin::Step& step) {
    std::vector<std::string> notes;
    
    // Add notes based on step content
    if (step.text().find("wait") != std::string::npos) {
        notes.push_back("Allow time for the operation to complete");
    }
    
    if (step.text().find("login") != std::string::npos) {
        notes.push_back("Ensure valid credentials are available");
    }
    
    if (step.text().find("upload") != std::string::npos) {
        notes.push_back("Prepare test file before executing this step");
    }
    
    if (include_screenshots_ && step.type() == gherkin::StepType::THEN) {
        notes.push_back("Take screenshot for verification");
    }
    
    return notes;
}

std::vector<std::string> ManualTestGenerator::convertDataTable(const gherkin::DataTable& table) {
    std::vector<std::string> result;
    
    for (const auto& row : table.rows()) {
        std::string rowStr = "| ";
        for (const auto& cell : row) {
            rowStr += cell + " | ";
        }
        result.push_back(rowStr);
    }
    
    return result;
}

std::string ManualTestGenerator::convertDocString(const gherkin::DocString& docString) {
    std::string result = "```";
    if (!docString.contentType().empty()) {
        result += docString.contentType();
    }
    result += "\n" + docString.content() + "\n```";
    return result;
}

std::unique_ptr<IFormatter> ManualTestGenerator::createFormatter(OutputFormat format) {
    switch (format) {
        case OutputFormat::MARKDOWN:
            return std::make_unique<MarkdownFormatter>();
        case OutputFormat::HTML:
            return std::make_unique<HtmlFormatter>();
        case OutputFormat::JSON:
            return std::make_unique<JsonFormatter>();
        default:
            return std::make_unique<MarkdownFormatter>();
    }
}

// MarkdownFormatter implementation
std::string MarkdownFormatter::format(const ManualTestSuite& suite) {
    std::stringstream ss;
    
    ss << "# Manual Test Suite: " << suite.name << "\n\n";
    
    if (!suite.description.empty()) {
        ss << suite.description << "\n\n";
    }
    
    ss << "**Version:** " << suite.version << "\n";
    ss << "**Author:** " << suite.author << "\n";
    ss << "**Created:** " << suite.created_date << "\n\n";
    
    ss << "## Test Cases\n\n";
    
    int index = 1;
    for (const auto& testCase : suite.test_cases) {
        ss << "### " << index++ << ". " << testCase.name << "\n\n";
        ss << formatTestCase(testCase) << "\n\n";
        ss << "---\n\n";
    }
    
    return ss.str();
}

std::string MarkdownFormatter::formatTestCase(const ManualTestCase& testCase) {
    std::stringstream ss;
    
    ss << "**Test ID:** " << testCase.id << "\n\n";
    
    if (!testCase.description.empty()) {
        ss << "**Description:** " << testCase.description << "\n\n";
    }
    
    if (!testCase.tags.empty()) {
        ss << formatTags(testCase.tags) << "\n\n";
    }
    
    if (!testCase.prerequisites.empty()) {
        ss << formatPrerequisites(testCase.prerequisites) << "\n\n";
    }
    
    ss << formatSteps(testCase.steps) << "\n\n";
    
    if (!testCase.expected_result.empty()) {
        ss << "#### Expected Result\n\n";
        ss << testCase.expected_result << "\n\n";
    }
    
    if (!testCase.test_data.empty()) {
        ss << formatTestData(testCase.test_data) << "\n";
    }
    
    return ss.str();
}

std::string MarkdownFormatter::formatTags(const std::vector<std::string>& tags) {
    std::stringstream ss;
    ss << "**Tags:** ";
    for (size_t i = 0; i < tags.size(); ++i) {
        ss << "`" << tags[i] << "`";
        if (i < tags.size() - 1) ss << " ";
    }
    return ss.str();
}

std::string MarkdownFormatter::formatPrerequisites(const std::vector<std::string>& prereqs) {
    std::stringstream ss;
    ss << "#### Prerequisites\n\n";
    for (const auto& prereq : prereqs) {
        ss << "- " << prereq << "\n";
    }
    return ss.str();
}

std::string MarkdownFormatter::formatSteps(const std::vector<ManualTestStep>& steps) {
    std::stringstream ss;
    ss << "#### Test Steps\n\n";
    
    int stepNum = 1;
    for (const auto& step : steps) {
        ss << stepNum++ << ". **" << step.action << "**\n";
        
        if (!step.expected.empty()) {
            ss << "   - Expected: " << step.expected << "\n";
        }
        
        if (!step.data.empty()) {
            ss << "   - Data: " << step.data << "\n";
        }
        
        for (const auto& note : step.notes) {
            ss << "   - Note: " << note << "\n";
        }
        
        ss << "\n";
    }
    
    return ss.str();
}

std::string MarkdownFormatter::formatTestData(const std::vector<std::string>& data) {
    std::stringstream ss;
    ss << "#### Test Data\n\n";
    for (const auto& item : data) {
        ss << item << "\n";
    }
    return ss.str();
}

// Utility functions
std::string generateTestId(const std::string& featureName, const std::string& scenarioName) {
    std::string id = "TC_";
    
    // Create short version of feature name
    std::string shortFeature;
    for (char c : featureName) {
        if (std::isupper(c)) {
            shortFeature += c;
        }
    }
    if (shortFeature.empty() && !featureName.empty()) {
        shortFeature = featureName.substr(0, 3);
    }
    
    // Create short version of scenario name
    std::string shortScenario;
    for (char c : scenarioName) {
        if (std::isupper(c)) {
            shortScenario += c;
        }
    }
    if (shortScenario.empty() && !scenarioName.empty()) {
        shortScenario = scenarioName.substr(0, 3);
    }
    
    // Add timestamp
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    
    id += shortFeature + "_" + shortScenario + "_" + std::to_string(time_t % 10000);
    
    return id;
}

std::string getCurrentDate() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

std::string stepTypeToInstruction(gherkin::StepType type) {
    switch (type) {
        case gherkin::StepType::GIVEN:
            return "Setup:";
        case gherkin::StepType::WHEN:
            return "Action:";
        case gherkin::StepType::THEN:
            return "Verify:";
        case gherkin::StepType::AND:
            return "And:";
        case gherkin::StepType::BUT:
            return "But:";
        default:
            return "Step:";
    }
}

} // namespace generator
} // namespace cucumber_cpp