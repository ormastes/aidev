/**
 * Markdown Processor for generating GitHub-compatible markdown documentation
 * Provides clean, version-control friendly documentation
 */

import { TestDocument, ProcessorResult, ManualGeneratorOptions, TestCase, DocumentSection } from '../core/types';

export class MarkdownProcessor {
  private options: ManualGeneratorOptions;

  constructor(options: ManualGeneratorOptions = {}) {
    this.options = options;
  }

  /**
   * Process document to Markdown format
   */
  async process(document: TestDocument): Promise<ProcessorResult> {
    try {
      const markdown = this.generateMarkdown(document);
      
      return {
        success: true,
        output: markdown,
        format: 'markdown'
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Markdown processing failed'
      };
    }
  }

  /**
   * Generate complete Markdown document
   */
  private generateMarkdown(document: TestDocument): string {
    const lines: string[] = [];
    
    // Title and metadata
    lines.push(`# ${document.title}`);
    lines.push('');
    
    if (document.version) {
      lines.push(`**Version:** ${document.version}`);
    }
    lines.push(`**Generated:** ${new Date(document.generatedAt).toISOString()}`);
    lines.push('');
    
    // Document metadata
    if (document.metadata && this.options.includeMetadata) {
      lines.push('## Document Information');
      lines.push('');
      
      if (document.metadata.author) {
        lines.push(`- **Author:** ${document.metadata.author}`);
      }
      if (document.metadata.tags && document.metadata.tags.length > 0) {
        lines.push(`- **Tags:** ${document.metadata.tags.map(tag => `\`${tag}\``).join(', ')}`);
      }
      if (document.metadata.requirements && document.metadata.requirements.length > 0) {
        lines.push(`- **Requirements:** ${document.metadata.requirements.join(', ')}`);
      }
      if (document.metadata.estimatedDuration) {
        lines.push(`- **Estimated Duration:** ${document.metadata.estimatedDuration} minutes`);
      }
      if (document.metadata.coverage) {
        lines.push(`- **Coverage:**`);
        lines.push(`  - Lines: ${document.metadata.coverage.lines}%`);
        lines.push(`  - Branches: ${document.metadata.coverage.branches}%`);
        lines.push(`  - Functions: ${document.metadata.coverage.functions}%`);
        lines.push(`  - Statements: ${document.metadata.coverage.statements}%`);
      }
      lines.push('');
    }
    
    // Table of Contents
    if (document.tableOfContents && this.options.generateTOC) {
      lines.push('## Table of Contents');
      lines.push('');
      document.tableOfContents.forEach(entry => {
        this.addTOCEntry(entry, lines, 0);
      });
      lines.push('');
    }
    
    // Main sections
    document.sections.forEach(section => {
      this.addSection(section, lines);
    });
    
    // Glossary
    if (document.glossary && document.glossary.length > 0) {
      lines.push('## Glossary');
      lines.push('');
      document.glossary.forEach(entry => {
        lines.push(`**${entry.term}:** ${entry.definition}`);
        lines.push('');
      });
    }
    
    // Index
    if (document.index && document.index.length > 0 && this.options.generateIndex) {
      lines.push('## Index');
      lines.push('');
      document.index.forEach(entry => {
        const refs = entry.references.map(ref => `[${ref}](#${ref})`).join(', ');
        lines.push(`- **${entry.term}:** ${refs}`);
      });
      lines.push('');
    }
    
    // Footer
    lines.push('---');
    lines.push('');
    lines.push(`*Generated by Enhanced Manual Generator on ${new Date(document.generatedAt).toLocaleString()}*`);
    
    return lines.join('\n');
  }

  /**
   * Add TOC entry to lines
   */
  private addTOCEntry(entry: any, lines: string[], depth: number): void {
    const indent = '  '.repeat(depth);
    const link = entry.href || `#${this.slugify(entry.title)}`;
    lines.push(`${indent}- [${entry.title}](${link})`);
    
    if (entry.children) {
      entry.children.forEach((child: any) => {
        this.addTOCEntry(child, lines, depth + 1);
      });
    }
  }

  /**
   * Add section to lines
   */
  private addSection(section: DocumentSection, lines: string[]): void {
    // Section heading
    const headingLevel = Math.min(section.level + 1, 6);
    const heading = '#'.repeat(headingLevel);
    lines.push(`${heading} ${section.title}`);
    lines.push('');
    
    // Section content
    if (section.content) {
      lines.push(section.content);
      lines.push('');
    }
    
    // Test cases
    if (section.testCases && section.testCases.length > 0) {
      lines.push(`### Test Cases`);
      lines.push('');
      
      section.testCases.forEach((testCase, index) => {
        this.addTestCase(testCase, lines, index + 1);
      });
    }
    
    // Screenshots
    if (section.screenshots && section.screenshots.length > 0) {
      lines.push(`### Screenshots`);
      lines.push('');
      section.screenshots.forEach(screenshot => {
        if (screenshot.caption) {
          lines.push(`![${screenshot.caption}](${screenshot.filePath})`);
        } else {
          lines.push(`![Screenshot](${screenshot.filePath})`);
        }
        lines.push('');
      });
    }
    
    // Subsections
    if (section.subsections) {
      section.subsections.forEach(subsection => {
        this.addSection(subsection, lines);
      });
    }
  }

  /**
   * Add test case to lines
   */
  private addTestCase(testCase: TestCase, lines: string[], number: number): void {
    // Test case header
    lines.push(`#### ${number}. ${testCase.name}`);
    lines.push('');
    
    // Priority badge
    if (testCase.priority) {
      const priorityEmoji = {
        critical: '🔴',
        high: '🟠',
        medium: '🟡',
        low: '🟢'
      };
      lines.push(`**Priority:** ${priorityEmoji[testCase.priority]} ${testCase.priority.charAt(0).toUpperCase() + testCase.priority.slice(1)}`);
      lines.push('');
    }
    
    // Description
    if (testCase.description) {
      lines.push(`**Description:** ${testCase.description}`);
      lines.push('');
    }
    
    // Category
    if (testCase.category) {
      lines.push(`**Category:** ${testCase.category}`);
      lines.push('');
    }
    
    // Tags
    if (testCase.tags && testCase.tags.length > 0) {
      lines.push(`**Tags:** ${testCase.tags.map(tag => `\`${tag}\``).join(', ')}`);
      lines.push('');
    }
    
    // Preconditions
    if (testCase.preconditions && testCase.preconditions.length > 0) {
      lines.push('**Preconditions:**');
      testCase.preconditions.forEach(condition => {
        lines.push(`- ${condition}`);
      });
      lines.push('');
    }
    
    // Test steps
    lines.push('**Test Steps:**');
    lines.push('');
    
    testCase.steps.forEach(step => {
      const stepType = {
        action: '🎯',
        assertion: '✓',
        setup: '⚙️',
        teardown: '🧹'
      };
      
      lines.push(`${step.order + 1}. ${stepType[step.type] || '•'} **${step.action}**`);
      
      if (step.expected) {
        lines.push(`   - *Expected:* ${step.expected}`);
      }
      
      if (step.actual) {
        lines.push(`   - *Actual:* ${step.actual}`);
      }
      
      if (step.data) {
        lines.push('   - *Data:*');
        lines.push('   ```json');
        lines.push(`   ${JSON.stringify(step.data, null, 2).split('\n').join('\n   ')}`);
        lines.push('   ```');
      }
      
      if (step.screenshot) {
        const caption = step.screenshot.caption || 'Screenshot';
        lines.push(`   - ![${caption}](${step.screenshot.filePath})`);
        
        if (step.screenshot.annotations && step.screenshot.annotations.length > 0) {
          lines.push('   - *Annotations:*');
          step.screenshot.annotations.forEach(annotation => {
            lines.push(`     - ${annotation.type}: ${annotation.text || 'N/A'}`);
          });
        }
      }
      
      lines.push('');
    });
    
    // Postconditions
    if (testCase.postconditions && testCase.postconditions.length > 0) {
      lines.push('**Postconditions:**');
      testCase.postconditions.forEach(condition => {
        lines.push(`- ${condition}`);
      });
      lines.push('');
    }
    
    lines.push('---');
    lines.push('');
  }

  /**
   * Convert title to slug for anchors
   */
  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/--+/g, '-') // Replace multiple hyphens with single
      .trim();
  }

  /**
   * Generate GitHub-flavored markdown table
   */
  generateTable(headers: string[], rows: string[][]): string {
    const lines: string[] = [];
    
    // Headers
    lines.push(`| ${headers.join(' | ')} |`);
    lines.push(`| ${headers.map(() => '---').join(' | ')} |`);
    
    // Rows
    rows.forEach(row => {
      lines.push(`| ${row.join(' | ')} |`);
    });
    
    return lines.join('\n');
  }

  /**
   * Generate collapsible section (details/summary)
   */
  generateCollapsible(summary: string, content: string): string {
    return `<details>
<summary>${summary}</summary>

${content}

</details>`;
  }

  /**
   * Generate badge (shields.io style)
   */
  generateBadge(label: string, message: string, color: string): string {
    const encodedLabel = encodeURIComponent(label);
    const encodedMessage = encodeURIComponent(message);
    return `![${label}](https://img.shields.io/badge/${encodedLabel}-${encodedMessage}-${color})`;
  }

  /**
   * Generate mermaid diagram
   */
  generateMermaidDiagram(type: 'flowchart' | 'sequence' | 'gantt', content: string): string {
    return `\`\`\`mermaid
${type} ${type === 'flowchart' ? 'LR' : ''}
${content}
\`\`\``;
  }

  /**
   * Format code block
   */
  formatCodeBlock(code: string, language: string = ''): string {
    return `\`\`\`${language}
${code}
\`\`\``;
  }

  /**
   * Generate task list
   */
  generateTaskList(tasks: { text: string; completed: boolean }[]): string {
    return tasks
      .map(task => `- [${task.completed ? 'x' : ' '}] ${task.text}`)
      .join('\n');
  }
}

export default MarkdownProcessor;