#!/usr/bin/env node

/**
 * Local MCP Test Runner - Tests without Docker
 */

const { spawn } = require('child_process');
const { path } = require('../infra_external-log-lib/src');
const fs = require('fs').promises;

// Test cases
const testCases = [
  {
    name: 'Root File Violation',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'check_file_allowed',
        arguments: {
          path: 'unauthorized.js',
          purpose: 'Test file in root'
        }
      },
      id: 1
    },
    expect: {
      allowed: false,
      hasIssues: true,
      issueType: 'ROOT_FILE_VIOLATION'
    }
  },
  {
    name: 'Allowed Root File',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'check_file_allowed',
        arguments: {
          path: 'README.md',
          purpose: 'Main documentation'
        }
      },
      id: 2
    },
    expect: {
      allowed: true,
      hasIssues: false
    }
  },
  {
    name: 'Allowed Directory',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'check_file_allowed',
        arguments: {
          path: 'gen/doc/report.md',
          purpose: 'Test report'
        }
      },
      id: 3
    },
    expect: {
      allowed: true,
      hasIssues: false
    }
  },
  {
    name: 'Write with Validation',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'write_file_with_validation',
        arguments: {
          path: 'gen/doc/test-report.md',
          content: '# Test Report\n\nGenerated by test',
          purpose: 'Automated test report',
          category: 'documentation',
          tags: ['test', 'report']
        }
      },
      id: 4
    },
    expect: {
      success: true
    }
  },
  {
    name: 'Block Root Write',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'write_file_with_validation',
        arguments: {
          path: 'blocked.js',
          content: '// Should be blocked',
          purpose: 'Unauthorized root file',
          category: 'utilities'
        }
      },
      id: 5
    },
    expect: {
      success: false,
      error: 'File creation not allowed'
    }
  },
  {
    name: 'Force Override with Justification',
    command: {
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'write_file_with_validation',
        arguments: {
          path: 'emergency.js',
          content: '// Emergency fix',
          purpose: 'Critical production fix',
          category: 'utilities',
          force: true,
          justification: 'Production issue #12345 requires immediate fix'
        }
      },
      id: 6
    },
    expect: {
      success: true,
      forced: true
    }
  }
];

// Send command to MCP server
async function sendCommand(command) {
  return new Promise((resolve, reject) => {
    const mcp = spawn('node', ['mcp-server-strict.js'], {
      env: {
        ...process.env,
        VF_BASE_PATH: process.cwd()
      }
    });

    let response = '';
    let error = '';

    mcp.stdout.on('data', (data) => {
      response += data.toString();
    });

    mcp.stderr.on('data', (data) => {
      error += data.toString();
    });

    mcp.on('close', (code) => {
      if (response) {
        try {
          const lines = response.split('\n').filter(line => line.trim());
          const lastLine = lines[lines.length - 1];
          const result = JSON.parse(lastLine);
          resolve(result);
        } catch (e) {
          resolve({ response, error });
        }
      } else {
        reject(new Error(error || 'No response'));
      }
    });

    mcp.stdin.write(JSON.stringify(command) + '\n');
    mcp.stdin.end();
  });
}

// Run tests
async function runTests() {
  console.log('🧪 Local MCP Test Suite\n');
  console.log('=' .repeat(50));
  
  let passed = 0;
  let failed = 0;
  
  for (const test of testCases) {
    console.log(`\n📝 Test: ${test.name}`);
    console.log('-'.repeat(40));
    
    try {
      const result = await sendCommand(test.command);
      
      if (result.result) {
        const content = result.result.content?.[0]?.text;
        if (content) {
          const parsed = JSON.parse(content);
          
          // Check expectations
          let testPassed = true;
          let failureReasons = [];
          
          if (test.expect.allowed !== undefined) {
            if (parsed.allowed !== test.expect.allowed) {
              testPassed = false;
              failureReasons.push(`Expected allowed=${test.expect.allowed}, got ${parsed.allowed}`);
            }
          }
          
          if (test.expect.success !== undefined) {
            if (parsed.success !== test.expect.success) {
              testPassed = false;
              failureReasons.push(`Expected success=${test.expect.success}, got ${parsed.success}`);
            }
          }
          
          if (test.expect.hasIssues !== undefined) {
            const hasIssues = parsed.issues && parsed.issues.length > 0;
            if (hasIssues !== test.expect.hasIssues) {
              testPassed = false;
              failureReasons.push(`Expected issues=${test.expect.hasIssues}, got ${hasIssues}`);
            }
          }
          
          if (test.expect.issueType) {
            const hasIssueType = parsed.issues?.some(i => i.type === test.expect.issueType);
            if (!hasIssueType) {
              testPassed = false;
              failureReasons.push(`Expected issue type ${test.expect.issueType} not found`);
            }
          }
          
          if (testPassed) {
            console.log('✅ PASS');
            passed++;
            
            // Show key details
            if (parsed.allowed !== undefined) {
              console.log(`   Allowed: ${parsed.allowed}`);
            }
            if (parsed.success !== undefined) {
              console.log(`   Success: ${parsed.success}`);
            }
            if (parsed.issues?.length > 0) {
              console.log(`   Issues: ${parsed.issues[0].message}`);
            }
            if (parsed.message) {
              console.log(`   Message: ${parsed.message}`);
            }
          } else {
            console.log('❌ FAIL');
            failed++;
            failureReasons.forEach(reason => {
              console.log(`   ${reason}`);
            });
          }
        }
      } else if (result.error) {
        console.log(`❌ ERROR: ${result.error.message || result.error}`);
        failed++;
      }
    } catch (error) {
      console.log(`❌ ERROR: ${error.message}`);
      failed++;
    }
  }
  
  // Summary
  console.log('\n' + '=' .repeat(50));
  console.log('📊 TEST SUMMARY');
  console.log('=' .repeat(50));
  console.log(`Total Tests: ${testCases.length}`);
  console.log(`Passed: ${passed} ✅`);
  console.log(`Failed: ${failed} ❌`);
  console.log(`Pass Rate: ${Math.round(passed / testCases.length * 100)}%`);
  console.log('=' .repeat(50));
  
  // Cleanup - remove test files created
  try {
    await fs.unlink('gen/doc/test-report.md').catch(() => {});
    await fs.unlink('emergency.js').catch(() => {});
  } catch {}
  
  return failed === 0;
}

// Main
runTests().then(success => {
  process.exit(success ? 0 : 1);
}).catch(error => {
  console.error('Test suite failed:', error);
  process.exit(1);
});