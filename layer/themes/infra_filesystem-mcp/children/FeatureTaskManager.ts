import { VFDistributedFeatureWrapper, DistributedFeature, DistributedFeatureFile } from './VFDistributedFeatureWrapper';
import { VFTaskQueueWrapper } from './VFTaskQueueWrapper';
import { FeatureStatusManager, StatusChangeValidation } from './FeatureStatusManager';
import { fsPromises as fs } from 'fs/promises';
import { path } from '../../infra_external-log-lib/src';
import { getFileAPI, FileType } from '../../infra_external-log-lib/pipe';

const fileAPI = getFileAPI();


export interface TaskQueueItem {
  id: string;
  type: string;
  priority: "critical" | 'high' | 'medium' | 'low';
  epic?: string;
  featureId?: string;
  content: {
    title: string;
    description: string;
    [key: string]: any;
  };
  status: 'pending' | 'in_progress' | "completed" | 'blocked';
  createdAt: string;
  updatedAt?: string;
  completedAt?: string;
}

export interface FeatureTaskLink {
  featureId: string;
  taskIds: string[];
  autoGenerated: boolean;
  createdAt: string;
}

export interface FeatureTaskOptions {
  autoCreateTasks?: boolean;
  autoDeleteOnComplete?: boolean;
  validateTasksOnStatusChange?: boolean;
  taskPriorityMapping?: Record<string, string>;
}

export class FeatureTaskManager {
  private featureWrapper: VFDistributedFeatureWrapper;
  private taskQueueWrapper: VFTaskQueueWrapper;
  private featureStatusManager: FeatureStatusManager;
  private basePath: string;
  private options: FeatureTaskOptions;
  private featureTaskLinks: Map<string, FeatureTaskLink> = new Map();

  constructor(basePath: string = process.cwd(), options: FeatureTaskOptions = {}) {
    this.basePath = basePath;
    this.options = {
      autoCreateTasks: true,
      autoDeleteOnComplete: true,
      validateTasksOnStatusChange: true,
      taskPriorityMapping: {
        "critical": "critical",
        'high': 'high',
        'medium': 'medium',
        'low': 'low'
      },
      ...options
    };

    this.featureWrapper = new VFDistributedFeatureWrapper(basePath);
    this.taskQueueWrapper = new VFTaskQueueWrapper(basePath);
    this.featureStatusManager = new FeatureStatusManager(basePath);
    
    // Load feature-task links on initialization
    this.loadFeatureTaskLinks();
  }

  /**
   * Load feature-task links from storage
   */
  private async loadFeatureTaskLinks(): Promise<void> {
    const linksPath = path.join(this.basePath, '.feature-task-links.json');
    try {
      const linksData = await fileAPI.readFile(linksPath, 'utf-8');
      const links = JSON.parse(linksData);
      this.featureTaskLinks = new Map(Object.entries(links));
    } catch {
      // File doesn't exist yet, start with empty map
      this.featureTaskLinks = new Map();
    }
  }

  /**
   * Save feature-task links to storage
   */
  private async saveFeatureTaskLinks(): Promise<void> {
    const linksPath = path.join(this.basePath, '.feature-task-links.json');
    const links = Object.fromEntries(this.featureTaskLinks);
    await fileAPI.createFile(linksPath, JSON.stringify(links, { type: FileType.TEMPORARY }));
  }

  /**
   * Add a new feature with optional auto-task creation
   */
  async addFeature(
    categoryName: string,
    feature: Omit<DistributedFeature, 'id' | "createdAt" | "updatedAt">,
    createTasks: boolean = true
  ): Promise<{ featureId: string; taskIds: string[]; validation: StatusChangeValidation }> {
    // Add feature using status manager for validation
    const result = await this.featureStatusManager.addFeature(categoryName, feature);
    
    const taskIds: string[] = [];
    
    // Auto-create tasks if enabled and requested
    if (this.options.autoCreateTasks && createTasks) {
      const createdTasks = await this.createTasksForFeature(result.id, feature);
      taskIds.push(...createdTasks);
      
      // Store the link
      this.featureTaskLinks.set(result.id, {
        featureId: result.id,
        taskIds,
        autoGenerated: true,
        createdAt: new Date().toISOString()
      });
      
      await this.saveFeatureTaskLinks();
    }
    
    return {
      featureId: result.id,
      taskIds,
      validation: result.validation
    };
  }

  /**
   * Create tasks for a feature based on its components/deliverables
   */
  private async createTasksForFeature(
    featureId: string,
    feature: Omit<DistributedFeature, 'id' | "createdAt" | "updatedAt">
  ): Promise<string[]> {
    const taskIds: string[] = [];
    const priority = this.options.taskPriorityMapping?.[feature.data.priority] || 'medium';
    
    // Create main feature implementation task
    const mainTask: Omit<TaskQueueItem, 'id' | "createdAt"> = {
      type: 'feature_implementation',
      priority: priority as any,
      epic: featureId,
      featureId: featureId,
      content: {
        title: `Implement ${feature.data.title}`,
        description: feature.data.description,
        feature: feature.data.title,
        autoGenerated: true
      },
      status: 'pending'
    };
    
    const mainTaskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const mainTaskWithId = { ...mainTask, id: mainTaskId, type: 'data' as const };
    await this.taskQueueWrapper.push(mainTaskWithId as any, priority as any, '/TASK_QUEUE.vf.json');
    taskIds.push(mainTaskId);
    
    // Create tasks for components if specified
    if (feature.data.components && Array.isArray(feature.data.components)) {
      for (const component of feature.data.components) {
        const componentTask: Omit<TaskQueueItem, 'id' | "createdAt"> = {
          type: 'feature_component',
          priority: priority as any,
          epic: featureId,
          featureId: featureId,
          content: {
            title: component,
            description: `Implement component: ${component}`,
            parentFeature: feature.data.title,
            autoGenerated: true
          },
          status: 'pending'
        };
        
        const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const taskWithId = { ...componentTask, id: taskId, type: 'data' as const };
        await this.taskQueueWrapper.push(taskWithId as any, priority as any, '/TASK_QUEUE.vf.json');
        taskIds.push(taskId);
      }
    }
    
    // Create tasks for acceptance criteria if specified
    if (feature.data.acceptanceCriteria && Array.isArray(feature.data.acceptanceCriteria)) {
      for (const criteria of feature.data.acceptanceCriteria) {
        const criteriaTask: Omit<TaskQueueItem, 'id' | "createdAt"> = {
          type: 'feature_criteria',
          priority: priority as any,
          epic: featureId,
          featureId: featureId,
          content: {
            title: `Verify: ${criteria}`,
            description: `Implement acceptance criteria: ${criteria}`,
            parentFeature: feature.data.title,
            autoGenerated: true
          },
          status: 'pending'
        };
        
        const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const taskWithId = { ...criteriaTask, id: taskId, type: 'data' as const };
        await this.taskQueueWrapper.push(taskWithId as any, priority as any, '/TASK_QUEUE.vf.json');
        taskIds.push(taskId);
      }
    }
    
    return taskIds;
  }

  /**
   * Update feature status with task validation
   */
  async updateFeatureStatus(
    featureId: string,
    newStatus: string,
    skipValidation: boolean = false
  ): Promise<StatusChangeValidation> {
    // Check for pending tasks if changing to completed
    if (newStatus === "completed" && this.options.validateTasksOnStatusChange && !skipValidation) {
      const validation = await this.validateFeatureTasks(featureId);
      if (!validation.isValid) {
        return validation;
      }
    }
    
    // Get feature to find category
    const featureFile = await this.featureWrapper.read('/FEATURE.vf.json');
    let categoryName = '';
    let feature: DistributedFeature | null = null;
    
    for (const [cat, features] of Object.entries(featureFile.features)) {
      const found = features.find(f => f.id === featureId);
      if (found) {
        categoryName = cat;
        feature = found;
        break;
      }
    }
    
    if (!feature || !categoryName) {
      return {
        isValid: false,
        errors: [`Feature ${featureId} not found`],
        warnings: []
      };
    }
    
    // Update status using status manager
    const result = await this.featureStatusManager.updateFeature({
      featureId,
      categoryName,
      updates: { status: newStatus as any },
      skipValidation
    });
    
    // Auto-delete tasks if feature is completed and option is enabled
    if (newStatus === "completed" && this.options.autoDeleteOnComplete && result.isValid) {
      await this.deleteFeatureTasks(featureId);
    }
    
    return result;
  }

  /**
   * Validate that all tasks for a feature are completed
   */
  async validateFeatureTasks(featureId: string): Promise<StatusChangeValidation> {
    const taskQueue = await this.taskQueueWrapper.read('/TASK_QUEUE.vf.json');
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // Find all tasks linked to this feature
    const linkedTasks: TaskQueueItem[] = [];
    
    // Check all priority queues
    for (const [priority, tasks] of Object.entries(taskQueue.taskQueues)) {
      if (Array.isArray(tasks)) {
        const featureTasks = tasks.filter(
          (task: any) => task.epic === featureId || task.featureId === featureId
        );
        linkedTasks.push(...featureTasks);
      }
    }
    
    // Check for pending or in-progress tasks
    const pendingTasks = linkedTasks.filter(
      task => task.status === 'pending' || task.status === 'in_progress'
    );
    
    const blockedTasks = linkedTasks.filter(task => task.status === 'blocked');
    
    if (pendingTasks.length > 0) {
      errors.push(
        `Cannot complete feature ${featureId}: ${pendingTasks.length} task(s) are still pending or in progress`
      );
      for (const task of pendingTasks) {
        errors.push(`  - ${task.id}: ${task.content.title} (${task.status})`);
      }
    }
    
    if (blockedTasks.length > 0) {
      warnings.push(
        `Feature ${featureId} has ${blockedTasks.length} blocked task(s)`
      );
      for (const task of blockedTasks) {
        warnings.push(`  - ${task.id}: ${task.content.title}`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Delete all tasks associated with a completed feature
   */
  async deleteFeatureTasks(featureId: string): Promise<string[]> {
    const taskQueue = await this.taskQueueWrapper.read('/TASK_QUEUE.vf.json');
    const deletedTaskIds: string[] = [];
    
    // Find and remove tasks from all priority queues
    for (const [priority, tasks] of Object.entries(taskQueue.taskQueues)) {
      if (Array.isArray(tasks)) {
        const remainingTasks = tasks.filter((task: any) => {
          const isFeatureTask = task.epic === featureId || task.featureId === featureId;
          const isCompleted = task.status === "completed";
          
          if (isFeatureTask && isCompleted) {
            deletedTaskIds.push(task.id);
            return false; // Remove from queue
          }
          return true; // Keep in queue
        });
        
        taskQueue.taskQueues[priority] = remainingTasks;
      }
    }
    
    // Update the task queue file
    if (deletedTaskIds.length > 0) {
      await this.taskQueueWrapper.write('/TASK_QUEUE.vf.json', taskQueue);
      
      // Remove feature-task link
      this.featureTaskLinks.delete(featureId);
      await this.saveFeatureTaskLinks();
    }
    
    return deletedTaskIds;
  }

  /**
   * Get all tasks for a feature
   */
  async getFeatureTasks(featureId: string): Promise<TaskQueueItem[]> {
    const taskQueue = await this.taskQueueWrapper.read('/TASK_QUEUE.vf.json');
    const featureTasks: TaskQueueItem[] = [];
    
    // Collect tasks from all priority queues
    for (const tasks of Object.values(taskQueue.taskQueues)) {
      if (Array.isArray(tasks)) {
        const matchingTasks = tasks.filter(
          (task: any) => task.epic === featureId || task.featureId === featureId
        );
        featureTasks.push(...matchingTasks);
      }
    }
    
    return featureTasks;
  }

  /**
   * Get feature-task summary report
   */
  async getFeatureTaskSummary(): Promise<{
    features: Array<{
      featureId: string;
      featureTitle: string;
      featureStatus: string;
      totalTasks: number;
      completedTasks: number;
      pendingTasks: number;
      blockedTasks: number;
      progress: number;
    }>;
    totals: {
      features: number;
      tasks: number;
      completedTasks: number;
      pendingTasks: number;
    };
  }> {
    const featureFile = await this.featureWrapper.read('/FEATURE.vf.json');
    const taskQueue = await this.taskQueueWrapper.read('/TASK_QUEUE.vf.json');
    
    const features: any[] = [];
    const allFeatures: DistributedFeature[] = [];
    
    // Collect all features
    for (const category of Object.values(featureFile.features)) {
      allFeatures.push(...category);
    }
    
    // Process each feature
    for (const feature of allFeatures) {
      const tasks = await this.getFeatureTasks(feature.id);
      const completedTasks = tasks.filter(t => t.status === "completed").length;
      const pendingTasks = tasks.filter(t => t.status === 'pending' || t.status === 'in_progress').length;
      const blockedTasks = tasks.filter(t => t.status === 'blocked').length;
      
      features.push({
        featureId: feature.id,
        featureTitle: feature.data.title,
        featureStatus: feature.data.status,
        totalTasks: tasks.length,
        completedTasks,
        pendingTasks,
        blockedTasks,
        progress: tasks.length > 0 ? (completedTasks / tasks.length) * 100 : 0
      });
    }
    
    // Calculate totals
    const totals = {
      features: features.length,
      tasks: features.reduce((sum, f) => sum + f.totalTasks, 0),
      completedTasks: features.reduce((sum, f) => sum + f.completedTasks, 0),
      pendingTasks: features.reduce((sum, f) => sum + f.pendingTasks, 0)
    };
    
    return { features, totals };
  }

  /**
   * Sync tasks with feature changes
   */
  async syncFeatureTasks(featureId: string): Promise<{
    added: string[];
    removed: string[];
    updated: string[];
  }> {
    const featureFile = await this.featureWrapper.read('/FEATURE.vf.json');
    let feature: DistributedFeature | null = null;
    
    // Find the feature
    for (const category of Object.values(featureFile.features)) {
      const found = category.find(f => f.id === featureId);
      if (found) {
        feature = found;
        break;
      }
    }
    
    if (!feature) {
      throw new Error(`Feature ${featureId} not found`);
    }
    
    const existingTasks = await this.getFeatureTasks(featureId);
    const result = {
      added: [] as string[],
      removed: [] as string[],
      updated: [] as string[]
    };
    
    // Check if we need to create new tasks for new deliverables/components
    const existingTitles = new Set(existingTasks.map(t => t.content.title));
    
    // Check components
    if (feature.data.components) {
      for (const component of feature.data.components) {
        if (!existingTitles.has(component)) {
          const task: Omit<TaskQueueItem, 'id' | "createdAt"> = {
            type: 'feature_component',
            priority: feature.data.priority as any,
            epic: featureId,
            featureId: featureId,
            content: {
              title: component,
              description: `Implement component: ${component}`,
              parentFeature: feature.data.title,
              autoGenerated: true,
              syncedAt: new Date().toISOString()
            },
            status: 'pending'
          };
          
          const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          const taskWithId = { ...task, id: taskId, type: 'data' as const };
          await this.taskQueueWrapper.push(taskWithId as any, feature.data.priority as any, '/TASK_QUEUE.vf.json');
          result.added.push(taskId);
        }
      }
    }
    
    // Update feature-task link
    const link = this.featureTaskLinks.get(featureId);
    if (link) {
      link.taskIds.push(...result.added);
      await this.saveFeatureTaskLinks();
    }
    
    return result;
  }

  /**
   * Manually link existing tasks to a feature
   */
  async linkTasksToFeature(featureId: string, taskIds: string[]): Promise<void> {
    const taskQueue = await this.taskQueueWrapper.read('/TASK_QUEUE.vf.json');
    
    // Update each task with the feature link
    for (const [priority, tasks] of Object.entries(taskQueue.taskQueues)) {
      if (Array.isArray(tasks)) {
        for (const task of tasks) {
          if (taskIds.includes(task.id)) {
            task.epic = featureId;
            task.featureId = featureId;
            task.updatedAt = new Date().toISOString();
          }
        }
      }
    }
    
    await this.taskQueueWrapper.write('/TASK_QUEUE.vf.json', taskQueue);
    
    // Update or create feature-task link
    const existingLink = this.featureTaskLinks.get(featureId);
    if (existingLink) {
      existingLink.taskIds = [...new Set([...existingLink.taskIds, ...taskIds])];
    } else {
      this.featureTaskLinks.set(featureId, {
        featureId,
        taskIds,
        autoGenerated: false,
        createdAt: new Date().toISOString()
      });
    }
    
    await this.saveFeatureTaskLinks();
  }
}

// Export factory function
export function createFeatureTaskManager(basePath?: string, options?: FeatureTaskOptions): FeatureTaskManager {
  return new FeatureTaskManager(basePath, options);
}