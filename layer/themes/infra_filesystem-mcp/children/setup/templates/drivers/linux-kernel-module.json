{
  "name": "linux-kernel-module",
  "description": "Linux kernel module/driver development template",
  "type": "os-driver",
  "language": "c",
  "platform": "linux",
  "supported_architectures": ["x86", "x86_64", "arm", "arm64", "riscv"],
  "dependencies": {
    "gcc": ">=9.0",
    "make": ">=4.0",
    "kernel-headers": "current",
    "kernel-devel": "current"
  },
  "files": {
    "src/driver.c": "#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n\n#define DEVICE_NAME \"${PROJECT_NAME}\"\n#define CLASS_NAME \"${PROJECT_NAME}_class\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"${AUTHOR}\");\nMODULE_DESCRIPTION(\"${PROJECT_DESCRIPTION}\");\nMODULE_VERSION(\"1.0\");\n\nstatic int majorNumber;\nstatic struct class* driverClass = NULL;\nstatic struct device* driverDevice = NULL;\n\nstatic int dev_open(struct inode *inodep, struct file *filep) {\n    printk(KERN_INFO \"%s: Device opened\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset) {\n    char message[] = \"Hello from kernel driver!\\n\";\n    size_t message_len = strlen(message);\n    \n    if (*offset >= message_len)\n        return 0;\n    \n    if (len > message_len - *offset)\n        len = message_len - *offset;\n    \n    if (copy_to_user(buffer, message + *offset, len))\n        return -EFAULT;\n    \n    *offset += len;\n    return len;\n}\n\nstatic ssize_t dev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset) {\n    printk(KERN_INFO \"%s: Received %zu bytes from user\\n\", DEVICE_NAME, len);\n    return len;\n}\n\nstatic int dev_release(struct inode *inodep, struct file *filep) {\n    printk(KERN_INFO \"%s: Device closed\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic struct file_operations fops = {\n    .open = dev_open,\n    .read = dev_read,\n    .write = dev_write,\n    .release = dev_release,\n};\n\nstatic int __init driver_init(void) {\n    printk(KERN_INFO \"%s: Initializing driver\\n\", DEVICE_NAME);\n    \n    // Register character device\n    majorNumber = register_chrdev(0, DEVICE_NAME, &fops);\n    if (majorNumber < 0) {\n        printk(KERN_ALERT \"%s: Failed to register major number\\n\", DEVICE_NAME);\n        return majorNumber;\n    }\n    printk(KERN_INFO \"%s: Registered with major number %d\\n\", DEVICE_NAME, majorNumber);\n    \n    // Register device class\n    driverClass = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(driverClass)) {\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"%s: Failed to register device class\\n\", DEVICE_NAME);\n        return PTR_ERR(driverClass);\n    }\n    \n    // Register device driver\n    driverDevice = device_create(driverClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);\n    if (IS_ERR(driverDevice)) {\n        class_destroy(driverClass);\n        unregister_chrdev(majorNumber, DEVICE_NAME);\n        printk(KERN_ALERT \"%s: Failed to create device\\n\", DEVICE_NAME);\n        return PTR_ERR(driverDevice);\n    }\n    \n    printk(KERN_INFO \"%s: Driver initialized successfully\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic void __exit driver_exit(void) {\n    device_destroy(driverClass, MKDEV(majorNumber, 0));\n    class_unregister(driverClass);\n    class_destroy(driverClass);\n    unregister_chrdev(majorNumber, DEVICE_NAME);\n    printk(KERN_INFO \"%s: Driver unloaded\\n\", DEVICE_NAME);\n}\n\nmodule_init(driver_init);\nmodule_exit(driver_exit);",
    "Makefile": "# Kernel module Makefile\nMODULE_NAME := ${PROJECT_NAME}\n\nifneq ($(KERNELRELEASE),)\n# Part executed when called from kernel build system\nobj-m := $(MODULE_NAME).o\n$(MODULE_NAME)-objs := src/driver.o\n\nelse\n# Part executed when called from command line\nKERNEL_DIR ?= /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\ndefault:\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean\n\ninstall:\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules_install\n\t/sbin/depmod -a\n\nload:\n\tsudo insmod $(MODULE_NAME).ko\n\nunload:\n\tsudo rmmod $(MODULE_NAME)\n\nreload: unload load\n\ntest:\n\t@echo \"Testing kernel module...\"\n\t@sudo dmesg | tail -20\n\t@echo \"Reading from device...\"\n\t@sudo cat /dev/$(MODULE_NAME)\n\ninfo:\n\t@echo \"Module info:\"\n\t@modinfo $(MODULE_NAME).ko\n\t@echo \"\\nLoaded modules:\"\n\t@lsmod | grep $(MODULE_NAME)\n\nendif",
    "test/test_driver.sh": "#!/bin/bash\n# Linux kernel driver test script\n\nset -e\n\nMODULE_NAME=\"${PROJECT_NAME}\"\nDEVICE=\"/dev/$MODULE_NAME\"\n\necho \"Testing kernel module: $MODULE_NAME\"\n\n# Build the module\necho \"Building module...\"\nmake clean\nmake\n\n# Load the module\necho \"Loading module...\"\nsudo insmod $MODULE_NAME.ko\n\n# Check if loaded\nif lsmod | grep -q $MODULE_NAME; then\n    echo \"✓ Module loaded successfully\"\nelse\n    echo \"✗ Module failed to load\"\n    exit 1\nfi\n\n# Check device creation\nif [ -e \"$DEVICE\" ]; then\n    echo \"✓ Device created: $DEVICE\"\nelse\n    echo \"✗ Device not created\"\n    sudo rmmod $MODULE_NAME\n    exit 1\nfi\n\n# Test read operation\necho \"Testing read operation...\"\nRESULT=$(sudo cat $DEVICE)\nif echo \"$RESULT\" | grep -q \"Hello from kernel driver\"; then\n    echo \"✓ Read operation successful\"\nelse\n    echo \"✗ Read operation failed\"\nfi\n\n# Test write operation\necho \"Testing write operation...\"\necho \"Test data\" | sudo tee $DEVICE > /dev/null\necho \"✓ Write operation completed\"\n\n# Check kernel logs\necho \"Checking kernel logs...\"\nsudo dmesg | tail -10\n\n# Unload the module\necho \"Unloading module...\"\nsudo rmmod $MODULE_NAME\n\nif lsmod | grep -q $MODULE_NAME; then\n    echo \"✗ Module failed to unload\"\n    exit 1\nelse\n    echo \"✓ Module unloaded successfully\"\nfi\n\necho \"\\n✓ All tests passed!\"",
    "test/test_driver.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n\n#define DEVICE_PATH \"/dev/${PROJECT_NAME}\"\n#define BUFFER_SIZE 256\n\nint main() {\n    int fd;\n    char buffer[BUFFER_SIZE];\n    ssize_t bytes_read, bytes_written;\n    \n    printf(\"Opening device: %s\\n\", DEVICE_PATH);\n    fd = open(DEVICE_PATH, O_RDWR);\n    if (fd < 0) {\n        perror(\"Failed to open device\");\n        return errno;\n    }\n    \n    // Test read\n    printf(\"Reading from device...\\n\");\n    memset(buffer, 0, BUFFER_SIZE);\n    bytes_read = read(fd, buffer, BUFFER_SIZE - 1);\n    if (bytes_read < 0) {\n        perror(\"Failed to read from device\");\n        close(fd);\n        return errno;\n    }\n    printf(\"Read %zd bytes: %s\\n\", bytes_read, buffer);\n    \n    // Test write\n    const char *test_data = \"Test data from userspace\\n\";\n    printf(\"Writing to device: %s\", test_data);\n    bytes_written = write(fd, test_data, strlen(test_data));\n    if (bytes_written < 0) {\n        perror(\"Failed to write to device\");\n        close(fd);\n        return errno;\n    }\n    printf(\"Wrote %zd bytes\\n\", bytes_written);\n    \n    close(fd);\n    printf(\"Device closed successfully\\n\");\n    \n    return 0;\n}",
    "README.md": "# ${PROJECT_NAME} - Linux Kernel Module\n\n## Description\n${PROJECT_DESCRIPTION}\n\n## Requirements\n- Linux kernel headers (linux-headers-$(uname -r))\n- GCC compiler\n- Make\n- Root/sudo access for loading/unloading\n\n## Building\n```bash\nmake\n```\n\n## Loading the Module\n```bash\nsudo insmod ${PROJECT_NAME}.ko\n# or\nmake load\n```\n\n## Testing\n```bash\n# Run automated tests\n./test/test_driver.sh\n\n# Manual testing\nsudo cat /dev/${PROJECT_NAME}\necho \"test\" | sudo tee /dev/${PROJECT_NAME}\n\n# Check kernel logs\nsudo dmesg | tail -20\n```\n\n## Unloading the Module\n```bash\nsudo rmmod ${PROJECT_NAME}\n# or\nmake unload\n```\n\n## Module Information\n```bash\nmodinfo ${PROJECT_NAME}.ko\nlsmod | grep ${PROJECT_NAME}\n```\n\n## Debugging\n- Check kernel logs: `sudo dmesg | tail -f`\n- Check module status: `lsmod | grep ${PROJECT_NAME}`\n- Check device: `ls -la /dev/${PROJECT_NAME}`\n\n## Files\n- `src/driver.c` - Main driver source code\n- `Makefile` - Build configuration\n- `test/test_driver.sh` - Automated test script\n- `test/test_driver.c` - Userspace test program\n\n## License\nGPL v2 (required for kernel modules)",
    ".gitignore": "*.o\n*.ko\n*.mod\n*.mod.c\n*.mod.o\n*.order\n*.symvers\n.tmp_versions/\nmodules.order\nModule.symvers\n.cache/\n.vscode/\nbuild/"
  },
  "test_config": {
    "framework": "catch2-cucumber",
    "kernel_test": true,
    "requires_root": true,
    "test_commands": [
      "make clean",
      "make",
      "sudo ./test/test_driver.sh"
    ]
  },
  "cross_compilation": {
    "arm": {
      "ARCH": "arm",
      "CROSS_COMPILE": "arm-linux-gnueabi-",
      "KERNEL_DIR": "/path/to/arm/kernel/build"
    },
    "arm64": {
      "ARCH": "arm64",
      "CROSS_COMPILE": "aarch64-linux-gnu-",
      "KERNEL_DIR": "/path/to/arm64/kernel/build"
    },
    "riscv": {
      "ARCH": "riscv",
      "CROSS_COMPILE": "riscv64-linux-gnu-",
      "KERNEL_DIR": "/path/to/riscv/kernel/build"
    }
  }
}