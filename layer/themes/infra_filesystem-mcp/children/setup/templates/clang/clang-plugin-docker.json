{
  "name": "clang-plugin-docker",
  "description": "Clang plugin development with Docker environment (LLVM pass manager, AST plugins)",
  "type": "clang-depend",
  "language": "cpp",
  "environment": "docker",
  "supported_architectures": ["x86_64", "arm64"],
  "dependencies": {
    "docker": ">=20.10",
    "cmake": ">=3.20"
  },
  "files": {
    "Dockerfile": "# Clang/LLVM Plugin Development Environment\nFROM ubuntu:22.04 as llvm-base\n\nARG LLVM_VERSION=15\n\n# Install dependencies\nRUN apt-get update && apt-get install -y \\\n    wget \\\n    software-properties-common \\\n    gnupg \\\n    && wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - \\\n    && add-apt-repository \"deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-${LLVM_VERSION} main\" \\\n    && apt-get update && apt-get install -y \\\n    clang-${LLVM_VERSION} \\\n    llvm-${LLVM_VERSION} \\\n    llvm-${LLVM_VERSION}-dev \\\n    libclang-${LLVM_VERSION}-dev \\\n    libclang-common-${LLVM_VERSION}-dev \\\n    libclang-cpp${LLVM_VERSION}-dev \\\n    clang-tools-${LLVM_VERSION} \\\n    libllvm${LLVM_VERSION} \\\n    llvm-${LLVM_VERSION}-runtime \\\n    build-essential \\\n    cmake \\\n    ninja-build \\\n    git \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set LLVM environment\nENV LLVM_DIR=/usr/lib/llvm-${LLVM_VERSION}\nENV PATH=$LLVM_DIR/bin:$PATH\nENV LD_LIBRARY_PATH=$LLVM_DIR/lib:$LD_LIBRARY_PATH\n\n# Development stage\nFROM llvm-base as development\n\n# Additional development tools\nRUN apt-get update && apt-get install -y \\\n    gdb \\\n    valgrind \\\n    ccache \\\n    vim \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /workspace\n\n# Copy plugin source\nCOPY . .\n\n# Build directory\nRUN mkdir -p build\n\n# Default command\nCMD [\"/bin/bash\"]",
    "docker-compose.yml": "version: '3.8'\n\nservices:\n  clang-plugin-dev:\n    build:\n      context: .\n      target: development\n      args:\n        LLVM_VERSION: 15\n    container_name: ${PROJECT_NAME}_clang_dev\n    volumes:\n      - .:/workspace\n      - build-cache:/workspace/build\n      - ccache:/root/.ccache\n    environment:\n      - LLVM_VERSION=15\n      - CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE:-Debug}\n      - CCACHE_DIR=/root/.ccache\n    command: /bin/bash\n    stdin_open: true\n    tty: true\n    networks:\n      - clang-network\n\n  clang-plugin-test:\n    build:\n      context: .\n      target: development\n    container_name: ${PROJECT_NAME}_clang_test\n    volumes:\n      - .:/workspace\n    command: |\n      bash -c \"cd /workspace && ./test.sh\"\n    networks:\n      - clang-network\n\nvolumes:\n  build-cache:\n  ccache:\n\nnetworks:\n  clang-network:\n    driver: bridge",
    "CMakeLists.txt": "cmake_minimum_required(VERSION 3.20)\nproject(${PROJECT_NAME}_plugin)\n\n# Find LLVM and Clang\nfind_package(LLVM REQUIRED CONFIG)\nfind_package(Clang REQUIRED CONFIG)\n\nmessage(STATUS \"Found LLVM ${LLVM_PACKAGE_VERSION}\")\nmessage(STATUS \"Using LLVMConfig.cmake in: ${LLVM_DIR}\")\nmessage(STATUS \"Using ClangConfig.cmake in: ${Clang_DIR}\")\n\n# Set C++ standard\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# LLVM compile flags\ninclude_directories(${LLVM_INCLUDE_DIRS})\ninclude_directories(${CLANG_INCLUDE_DIRS})\nadd_definitions(${LLVM_DEFINITIONS})\n\n# Plugin type selection\noption(BUILD_AST_PLUGIN \"Build AST manipulation plugin\" ON)\noption(BUILD_PASS_PLUGIN \"Build LLVM pass plugin\" ON)\noption(BUILD_STATIC_ANALYZER \"Build static analyzer checker\" OFF)\n\n# AST Plugin\nif(BUILD_AST_PLUGIN)\n    add_library(${PROJECT_NAME}ASTPlugin MODULE\n        src/ast_plugin.cpp\n    )\n    \n    target_link_libraries(${PROJECT_NAME}ASTPlugin PRIVATE\n        clangAST\n        clangBasic\n        clangFrontend\n        clangTooling\n    )\nendif()\n\n# LLVM Pass Plugin\nif(BUILD_PASS_PLUGIN)\n    add_library(${PROJECT_NAME}Pass MODULE\n        src/pass_plugin.cpp\n    )\n    \n    # Don't link against LLVM libraries for a pass plugin\n    set_target_properties(${PROJECT_NAME}Pass PROPERTIES\n        LINK_FLAGS \"-Wl,-znodelete\"\n    )\nendif()\n\n# Static Analyzer Plugin\nif(BUILD_STATIC_ANALYZER)\n    add_library(${PROJECT_NAME}Checker MODULE\n        src/checker_plugin.cpp\n    )\n    \n    target_link_libraries(${PROJECT_NAME}Checker PRIVATE\n        clangStaticAnalyzerCore\n        clangStaticAnalyzerFrontend\n    )\nendif()\n\n# Test executable\nadd_executable(test_plugin\n    test/test_main.cpp\n)\n\ntarget_link_libraries(test_plugin\n    clangTooling\n    clangBasic\n    clangAST\n    clangFrontend\n)",
    "src/ast_plugin.cpp": "#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace clang;\n\nnamespace {\n\nclass ${PROJECT_NAME}Visitor : public RecursiveASTVisitor<${PROJECT_NAME}Visitor> {\nprivate:\n    ASTContext *Context;\n    \npublic:\n    explicit ${PROJECT_NAME}Visitor(ASTContext *Context)\n        : Context(Context) {}\n    \n    bool VisitFunctionDecl(FunctionDecl *F) {\n        // Process function declarations\n        if (F->hasBody()) {\n            llvm::outs() << \"Function: \" << F->getNameInfo().getAsString() << \"\\n\";\n            \n            // Example: Count parameters\n            llvm::outs() << \"  Parameters: \" << F->getNumParams() << \"\\n\";\n            \n            // Example: Check for specific attributes\n            if (F->hasAttr<NoReturnAttr>()) {\n                llvm::outs() << \"  Has noreturn attribute\\n\";\n            }\n        }\n        return true;\n    }\n    \n    bool VisitVarDecl(VarDecl *V) {\n        // Process variable declarations\n        llvm::outs() << \"Variable: \" << V->getNameAsString()\n                     << \" Type: \" << V->getType().getAsString() << \"\\n\";\n        return true;\n    }\n};\n\nclass ${PROJECT_NAME}Consumer : public ASTConsumer {\nprivate:\n    ${PROJECT_NAME}Visitor Visitor;\n    \npublic:\n    explicit ${PROJECT_NAME}Consumer(ASTContext *Context)\n        : Visitor(Context) {}\n    \n    void HandleTranslationUnit(ASTContext &Context) override {\n        Visitor.TraverseDecl(Context.getTranslationUnitDecl());\n    }\n};\n\nclass ${PROJECT_NAME}Action : public PluginASTAction {\nprotected:\n    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                   StringRef file) override {\n        return std::make_unique<${PROJECT_NAME}Consumer>(&CI.getASTContext());\n    }\n    \n    bool ParseArgs(const CompilerInstance &CI,\n                   const std::vector<std::string> &args) override {\n        // Parse plugin arguments if needed\n        for (const auto &arg : args) {\n            llvm::outs() << \"Plugin arg: \" << arg << \"\\n\";\n        }\n        return true;\n    }\n    \n    PluginASTAction::ActionType getActionType() override {\n        return AddBeforeMainAction;\n    }\n};\n\n} // namespace\n\nstatic FrontendPluginRegistry::Add<${PROJECT_NAME}Action>\n    X(\"${PROJECT_NAME}\", \"${PROJECT_NAME} AST Plugin\");",
    "src/pass_plugin.cpp": "#include \"llvm/Pass.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n\nusing namespace llvm;\n\nnamespace {\n\n// Function Pass\nstruct ${PROJECT_NAME}FunctionPass : public PassInfoMixin<${PROJECT_NAME}FunctionPass> {\n    PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM) {\n        errs() << \"Function Pass: \" << F.getName() << \"\\n\";\n        \n        // Example: Count instructions\n        int instructionCount = 0;\n        for (auto &BB : F) {\n            for (auto &I : BB) {\n                instructionCount++;\n                \n                // Example: Find call instructions\n                if (auto *CI = dyn_cast<CallInst>(&I)) {\n                    if (Function *Callee = CI->getCalledFunction()) {\n                        errs() << \"  Calls: \" << Callee->getName() << \"\\n\";\n                    }\n                }\n            }\n        }\n        \n        errs() << \"  Total instructions: \" << instructionCount << \"\\n\";\n        \n        return PreservedAnalyses::all();\n    }\n};\n\n// Module Pass\nstruct ${PROJECT_NAME}ModulePass : public PassInfoMixin<${PROJECT_NAME}ModulePass> {\n    PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM) {\n        errs() << \"Module Pass: \" << M.getName() << \"\\n\";\n        \n        // Example: Count functions\n        int functionCount = 0;\n        for (auto &F : M) {\n            if (!F.isDeclaration()) {\n                functionCount++;\n            }\n        }\n        \n        errs() << \"  Total functions: \" << functionCount << \"\\n\";\n        \n        return PreservedAnalyses::all();\n    }\n};\n\n} // namespace\n\n// Pass registration\nextern \"C\" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,\n        \"${PROJECT_NAME}Pass\",\n        \"v0.1\",\n        [](PassBuilder &PB) {\n            // Register function pass\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &FPM,\n                   ArrayRef<PassBuilder::PipelineElement>) {\n                    if (Name == \"${PROJECT_NAME}-function\") {\n                        FPM.addPass(${PROJECT_NAME}FunctionPass());\n                        return true;\n                    }\n                    return false;\n                });\n            \n            // Register module pass\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, ModulePassManager &MPM,\n                   ArrayRef<PassBuilder::PipelineElement>) {\n                    if (Name == \"${PROJECT_NAME}-module\") {\n                        MPM.addPass(${PROJECT_NAME}ModulePass());\n                        return true;\n                    }\n                    return false;\n                });\n            \n            // Register as part of optimization pipeline\n            PB.registerOptimizerLastEPCallback(\n                [](ModulePassManager &MPM, OptimizationLevel Level) {\n                    MPM.addPass(${PROJECT_NAME}ModulePass());\n                });\n        }\n    };\n}",
    "test/hello_world.cpp": "// Hello World test file for Clang plugins\n#include <iostream>\n#include <string>\n\n// This function will be analyzed by the AST plugin\nvoid helloWorld() {\n    std::cout << \"Hello from Clang Plugin Test!\" << std::endl;\n}\n\n// This function will be optimized by the pass plugin\nint compute(int x) {\n    // Intentionally inefficient for demo\n    int result = 0;\n    for (int i = 0; i < x; ++i) {\n        result += 1;\n    }\n    return result;\n}\n\nclass HelloClass {\nprivate:\n    std::string message;\n    \npublic:\n    HelloClass() : message(\"Hello from analyzed class\") {}\n    \n    void printMessage() {\n        std::cout << message << std::endl;\n    }\n    \n    int getValue() const {\n        return 42;\n    }\n};\n\nint main() {\n    std::cout << \"=== Clang Plugin Hello World ===\" << std::endl;\n    \n    // Call function that will be analyzed\n    helloWorld();\n    \n    // Use class that will be analyzed\n    HelloClass hello;\n    hello.printMessage();\n    \n    // Call function that will be optimized\n    int result = compute(10);\n    std::cout << \"Computed result: \" << result << std::endl;\n    \n    std::cout << \"=== Plugin test completed ===\" << std::endl;\n    return 0;\n}",
    "build.sh": "#!/bin/bash\n# Build Clang plugin in Docker\n\nset -e\n\nPROJECT_NAME=\"${PROJECT_NAME}\"\n\necho \"Building Clang plugin in Docker...\"\n\n# Build the Docker image\ndocker-compose build clang-plugin-dev\n\n# Build the plugin\ndocker-compose run --rm clang-plugin-dev bash -c \"\n    cd /workspace && \n    mkdir -p build && \n    cd build && \n    cmake -G Ninja \\\n          -DCMAKE_BUILD_TYPE=Debug \\\n          -DBUILD_AST_PLUGIN=ON \\\n          -DBUILD_PASS_PLUGIN=ON \\\n          .. && \n    ninja\n\"\n\necho \"Build complete!\"",
    "test.sh": "#!/bin/bash\n# Test Clang plugin in Docker\n\nset -e\n\nPROJECT_NAME=\"${PROJECT_NAME}\"\n\necho \"Testing Clang plugin...\"\n\n# Run tests in Docker\ndocker-compose run --rm clang-plugin-dev bash -c \"\n    cd /workspace/build && \n    echo '=== Testing AST Plugin ===' && \n    clang++ -fplugin=./lib${PROJECT_NAME}ASTPlugin.so \\\n            -c ../test/hello_world.cpp && \n    echo '=== Testing Pass Plugin ===' && \n    clang++ -fpass-plugin=./lib${PROJECT_NAME}Pass.so \\\n            -O2 ../test/hello_world.cpp -o test_binary && \n    echo '=== Running test binary ===' && \n    ./test_binary\n\"\n\necho \"Tests complete!\"",
    "run_hello_world.sh": "#!/bin/bash\n# Run hello world with Clang plugins\n\nset -e\n\nPROJECT_NAME=\"${PROJECT_NAME}\"\n\necho \"=== Clang Plugin Hello World Demo ===\"\necho \"\"\necho \"This will:\"\necho \"1. Build the plugins if needed\"\necho \"2. Compile hello_world.cpp with AST plugin (shows AST analysis)\"\necho \"3. Compile hello_world.cpp with Pass plugin (shows optimization passes)\"\necho \"4. Run the resulting binary\"\necho \"\"\n\n# Build if not already built\nif [ ! -d \"build\" ]; then\n    echo \"Building plugins first...\"\n    ./build.sh\nfi\n\n# Run hello world with plugins\ndocker-compose run --rm clang-plugin-dev bash -c \"\n    cd /workspace/build && \n    echo '===========================================\" && \n    echo '=== Step 1: AST Plugin Analysis ===' && \n    echo '===========================================\" && \n    echo 'Compiling with AST plugin to analyze code structure:' && \n    echo '' && \n    clang++ -fplugin=./lib${PROJECT_NAME}ASTPlugin.so \\\n            -c ../test/hello_world.cpp -o hello_ast.o 2>&1 | head -20 && \n    echo '' && \n    echo '===========================================\" && \n    echo '=== Step 2: Pass Plugin Optimization ===' && \n    echo '===========================================\" && \n    echo 'Compiling with Pass plugin for optimization analysis:' && \n    echo '' && \n    clang++ -fpass-plugin=./lib${PROJECT_NAME}Pass.so \\\n            -O2 ../test/hello_world.cpp -o hello_world 2>&1 | head -20 && \n    echo '' && \n    echo '===========================================\" && \n    echo '=== Step 3: Running Hello World ===' && \n    echo '===========================================\" && \n    ./hello_world && \n    echo '' && \n    echo '===========================================\" && \n    echo '=== Plugin Demo Completed Successfully! ===' && \n    echo '===========================================\" \n\"\n\necho \"\"\necho \"Hello World with Clang plugins completed!\"",
    "run-docker.sh": "#!/bin/bash\n# Interactive Docker shell for development\n\nset -e\n\necho \"Starting interactive Docker shell...\"\n\ndocker-compose run --rm clang-plugin-dev",
    ".dockerignore": "build/\n*.o\n*.so\n*.a\n.git/\n.vscode/\n.idea/\n*.swp\n*.bak"
  },
  "test_config": {
    "framework": "catch2",
    "environment": "docker",
    "commands": [
      "./test.sh"
    ]
  },
  "usage_examples": {
    "ast_plugin": "clang++ -fplugin=./lib${PROJECT_NAME}ASTPlugin.so -c source.cpp",
    "pass_plugin": "clang++ -fpass-plugin=./lib${PROJECT_NAME}Pass.so -O2 source.cpp",
    "opt_tool": "opt -load-pass-plugin=./lib${PROJECT_NAME}Pass.so -passes='${PROJECT_NAME}-module' < input.ll > output.ll"
  }
}