{
  "name": "cpp-library-docker",
  "description": "C++ library development with Docker as default environment",
  "type": "library",
  "language": "cpp",
  "environment": "docker",
  "supported_architectures": ["x86_64", "arm64"],
  "supported_os": ["linux", "windows", "macos"],
  "dependencies": {
    "cmake": ">=3.20",
    "docker": ">=20.10"
  },
  "files": {
    "Dockerfile": "# Multi-stage C++ library build\nFROM ubuntu:22.04 as build-base\n\n# Install build essentials\nRUN apt-get update && apt-get install -y \\\n    build-essential \\\n    cmake \\\n    ninja-build \\\n    git \\\n    wget \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Development stage with all tools\nFROM build-base as development\n\nRUN apt-get update && apt-get install -y \\\n    clang-15 \\\n    clang-tools-15 \\\n    llvm-15-dev \\\n    libclang-15-dev \\\n    gdb \\\n    valgrind \\\n    ccache \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /workspace\n\n# Copy library source\nCOPY . .\n\n# Build library\nRUN mkdir -p build && cd build && \\\n    cmake -G Ninja \\\n          -DCMAKE_BUILD_TYPE=Release \\\n          -DCMAKE_CXX_COMPILER=clang++-15 \\\n          -DCMAKE_C_COMPILER=clang-15 \\\n          .. && \\\n    ninja\n\n# Production stage - minimal runtime\nFROM ubuntu:22.04 as production\n\nRUN apt-get update && apt-get install -y \\\n    libstdc++6 \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /usr/local\n\n# Copy built library\nCOPY --from=development /workspace/build/lib* ./lib/\nCOPY --from=development /workspace/build/include ./include/\n\n# Runtime configuration\nENV LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH",
    "docker-compose.yml": "version: '3.8'\n\nservices:\n  cpp-dev:\n    build:\n      context: .\n      target: development\n    container_name: ${PROJECT_NAME}_dev\n    volumes:\n      - .:/workspace\n      - build-cache:/workspace/build\n      - ccache:/root/.ccache\n    environment:\n      - CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE:-Debug}\n      - CCACHE_DIR=/root/.ccache\n    command: /bin/bash\n    stdin_open: true\n    tty: true\n    networks:\n      - cpp-network\n\n  cpp-test:\n    build:\n      context: .\n      target: development\n    container_name: ${PROJECT_NAME}_test\n    volumes:\n      - .:/workspace\n    command: |\n      bash -c \"cd /workspace/build && \\\n               ctest --output-on-failure\"\n    networks:\n      - cpp-network\n\nvolumes:\n  build-cache:\n  ccache:\n\nnetworks:\n  cpp-network:\n    driver: bridge",
    "CMakeLists.txt": "cmake_minimum_required(VERSION 3.20)\nproject(${PROJECT_NAME} VERSION 1.0.0 LANGUAGES CXX)\n\n# Set C++ standard\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\n# Export compile commands for clang tools\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Options\noption(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\noption(BUILD_TESTS \"Build tests\" ON)\noption(BUILD_EXAMPLES \"Build examples\" ON)\n\n# Library sources\nset(LIBRARY_SOURCES\n    src/library.cpp\n)\n\nset(LIBRARY_HEADERS\n    include/${PROJECT_NAME}/library.hpp\n)\n\n# Create library target\nadd_library(${PROJECT_NAME} ${LIBRARY_SOURCES})\n\n# Set include directories\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n        $<INSTALL_INTERFACE:include>\n    PRIVATE\n        ${CMAKE_CURRENT_SOURCE_DIR}/src\n)\n\n# Set compile features\ntarget_compile_features(${PROJECT_NAME} PUBLIC cxx_std_17)\n\n# Add compile options\ntarget_compile_options(${PROJECT_NAME} PRIVATE\n    $<$<CXX_COMPILER_ID:Clang>:-Wall -Wextra -Wpedantic>\n    $<$<CXX_COMPILER_ID:GNU>:-Wall -Wextra -Wpedantic>\n)\n\n# Testing\nif(BUILD_TESTS)\n    enable_testing()\n    add_subdirectory(tests)\nendif()\n\n# Examples\nif(BUILD_EXAMPLES)\n    add_subdirectory(examples)\nendif()\n\n# Installation\ninclude(GNUInstallDirs)\ninstall(TARGETS ${PROJECT_NAME}\n    EXPORT ${PROJECT_NAME}Targets\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n\ninstall(DIRECTORY include/\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n)\n\n# Export targets\ninstall(EXPORT ${PROJECT_NAME}Targets\n    FILE ${PROJECT_NAME}Config.cmake\n    NAMESPACE ${PROJECT_NAME}::\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\n)",
    "include/library.hpp": "#pragma once\n\n#include <string>\n#include <memory>\n\nnamespace ${PROJECT_NAME} {\n\nclass Library {\npublic:\n    Library();\n    ~Library();\n    \n    // Disable copy\n    Library(const Library&) = delete;\n    Library& operator=(const Library&) = delete;\n    \n    // Enable move\n    Library(Library&&) noexcept;\n    Library& operator=(Library&&) noexcept;\n    \n    // Public API\n    std::string getVersion() const;\n    bool initialize();\n    void process();\n    \nprivate:\n    class Impl;\n    std::unique_ptr<Impl> pImpl;\n};\n\n} // namespace ${PROJECT_NAME}",
    "src/library.cpp": "#include \"${PROJECT_NAME}/library.hpp\"\n#include <iostream>\n\nnamespace ${PROJECT_NAME} {\n\nclass Library::Impl {\npublic:\n    Impl() : initialized(false) {}\n    \n    bool initialized;\n    std::string version = \"1.0.0\";\n};\n\nLibrary::Library() : pImpl(std::make_unique<Impl>()) {}\n\nLibrary::~Library() = default;\n\nLibrary::Library(Library&&) noexcept = default;\n\nLibrary& Library::operator=(Library&&) noexcept = default;\n\nstd::string Library::getVersion() const {\n    return pImpl->version;\n}\n\nbool Library::initialize() {\n    if (pImpl->initialized) {\n        return true;\n    }\n    \n    // Initialization logic\n    std::cout << \"Initializing library version \" << pImpl->version << std::endl;\n    pImpl->initialized = true;\n    return true;\n}\n\nvoid Library::process() {\n    if (!pImpl->initialized) {\n        throw std::runtime_error(\"Library not initialized\");\n    }\n    \n    // Processing logic\n    std::cout << \"Processing...\" << std::endl;\n}\n\nstd::string Library::getHelloMessage() const {\n    return \"Hello from C++ Library (Docker)!\";\n}\n\n} // namespace ${PROJECT_NAME}",
    "include/library.hpp": "#pragma once\n\n#include <string>\n#include <memory>\n\nnamespace ${PROJECT_NAME} {\n\nclass Library {\npublic:\n    Library();\n    ~Library();\n    \n    // Disable copy\n    Library(const Library&) = delete;\n    Library& operator=(const Library&) = delete;\n    \n    // Enable move\n    Library(Library&&) noexcept;\n    Library& operator=(Library&&) noexcept;\n    \n    // Public API\n    std::string getVersion() const;\n    std::string getHelloMessage() const;\n    bool initialize();\n    void process();\n    \nprivate:\n    class Impl;\n    std::unique_ptr<Impl> pImpl;\n};\n\n} // namespace ${PROJECT_NAME}",
    "examples/hello_world.cpp": "#include <iostream>\n#include \"${PROJECT_NAME}/library.hpp\"\n\nint main() {\n    std::cout << \"=== C++ Library Hello World Example ===\" << std::endl;\n    \n    // Create library instance\n    ${PROJECT_NAME}::Library lib;\n    \n    // Get version\n    std::cout << \"Library version: \" << lib.getVersion() << std::endl;\n    \n    // Initialize\n    if (lib.initialize()) {\n        std::cout << \"Library initialized successfully!\" << std::endl;\n    }\n    \n    // Get hello message\n    std::cout << lib.getHelloMessage() << std::endl;\n    \n    // Process something\n    lib.process();\n    \n    std::cout << \"=== Example completed successfully! ===\" << std::endl;\n    return 0;\n}",
    "examples/CMakeLists.txt": "# Examples CMakeLists.txt\n\n# Hello World example\nadd_executable(hello_world hello_world.cpp)\ntarget_link_libraries(hello_world ${PROJECT_NAME})\n\n# Add to test\nadd_test(NAME hello_world_test COMMAND hello_world)",
    "build.sh": "#!/bin/bash\n# Build script for Docker environment\n\nset -e\n\nPROJECT_NAME=\"${PROJECT_NAME}\"\nBUILD_TYPE=\"${BUILD_TYPE:-Release}\"\n\necho \"Building $PROJECT_NAME in Docker...\"\n\n# Build Docker image\ndocker-compose build cpp-dev\n\n# Run build in container\ndocker-compose run --rm cpp-dev bash -c \"\n    mkdir -p build && \n    cd build && \n    cmake -G Ninja \\\n          -DCMAKE_BUILD_TYPE=$BUILD_TYPE \\\n          -DCMAKE_CXX_COMPILER=clang++-15 \\\n          -DCMAKE_C_COMPILER=clang-15 \\\n          .. && \n    ninja\n\"\n\necho \"Build complete!\"",
    "test.sh": "#!/bin/bash\n# Test script for Docker environment\n\nset -e\n\necho \"Running tests in Docker...\"\n\ndocker-compose run --rm cpp-test\n\necho \"Tests complete!\"",
    "run_hello_world.sh": "#!/bin/bash\n# Run hello world example in Docker\n\nset -e\n\nPROJECT_NAME=\"${PROJECT_NAME}\"\n\necho \"Building and running Hello World example in Docker...\"\n\n# Build if not already built\nif [ ! -d \"build\" ]; then\n    ./build.sh\nfi\n\n# Run hello world in container\ndocker-compose run --rm cpp-dev bash -c \"\n    cd /workspace/build && \n    if [ ! -f examples/hello_world ]; then\n        cmake -DBUILD_EXAMPLES=ON .. && \n        ninja\n    fi && \n    echo '=== Running Hello World ===' && \n    ./examples/hello_world\n\"\n\necho \"Hello World example completed!\"",
    ".dockerignore": "build/\n*.o\n*.so\n*.a\n.git/\n.vscode/\n.idea/\n*.swp\n*.bak\nDockerfile\ndocker-compose.yml"
  },
  "test_config": {
    "framework": "catch2",
    "environment": "docker",
    "commands": [
      "./test.sh"
    ]
  }
}