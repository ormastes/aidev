import { path } from '../../../../../../../infra_external-log-lib/src';
import * as fs from 'fs-extra';
import chalk from 'chalk';
import ora from 'ora';
import { ReleaseSetupOptions, ReleaseType } from '../types';
import { BaseSetup } from './base-setup';

export class ReleaseSetup extends BaseSetup {
  private releaseType: ReleaseType;
  private domain?: string;
  private dbHost?: string;
  private dbPort?: string;
  private port?: string;

  constructor(options: ReleaseSetupOptions) {
    super(options, 'release');
    this.releaseType = options.releaseType;
    this.domain = options.domain;
    this.dbHost = options.dbHost || 'localhost';
    this.dbPort = options.dbPort || '5432';
    this.port = options.port || '3456';
  }

  getDeployDir(): string {
    const timestamp = new Date().toISOString().split('T')[0].replace(/-/g, '.');
    return path.join(this.baseDir, 'scripts', 'setup', 'release', `${this.appName}_v${timestamp}`);
  }

  getDbPassword(): string {
    // Generate secure password for production
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < 32; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }

  getEnvConfig(): string {
    return `# Production Environment Configuration
# Auto-generated by aidev-setup
# Port Policy: Production uses 3400-3499

# Database Configuration - PostgreSQL for Production
DB_TYPE=postgres
DB_HOST=${this.dbHost}
DB_PORT=${this.dbPort}
DB_USER=${this.dbUser}
DB_PASSWORD=${this.dbPassword}
DB_NAME=${this.dbName}

# Server Configuration
PORT=${this.port}
JWT_SECRET=${this.generateJwtSecret()}
NODE_ENV=production

# Domain Configuration
DOMAIN=${this.domain || 'localhost'}
HTTPS_ENABLED=${this.domain ? 'true' : 'false'}

# Release Configuration
RELEASE_TYPE=${this.releaseType}
VERSION=1.0.0
BUILD_DATE=${new Date().toISOString()}

# Features
MODE=${this.mode.toUpperCase()}
LOG_LEVEL=info
ENABLE_METRICS=true
ENABLE_HEALTH_CHECK=true
`;
  }

  private generateJwtSecret(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let secret = '';
    for (let i = 0; i < 64; i++) {
      secret += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return secret;
  }

  async createDeploymentConfig(): Promise<boolean> {
    const spinner = ora('Creating release deployment configuration...').start();
    
    try {
      // Create release-specific configuration based on type
      switch (this.releaseType) {
        case 'web-server':
          await this.createWebServerRelease();
          break;
        case 'mcp':
          await this.createMcpRelease();
          break;
        case 'cli':
          await this.createCliRelease();
          break;
        case 'api':
          await this.createApiRelease();
          break;
        case 'library':
          await this.createLibraryRelease();
          break;
      }

      // Create common release files
      await this.createDockerfile();
      await this.createDockerCompose();
      await this.createSystemdService();
      await this.createNginxConfig();
      await this.saveDbPassword();

      // Deploy CLAUDE.md and llm_rules for all release types
      await this.deployClaudeConfig();

      spinner.succeed('Created release deployment configuration');
      return true;
    } catch (error) {
      spinner.fail(`Failed to create deployment config: ${error}`);
      return false;
    }
  }

  private async createWebServerRelease(): Promise<void> {
    const packageJson = {
      name: `${this.appName}-production`,
      version: '1.0.0',
      description: `${this.appName} - Production Web Server`,
      main: 'dist/server.js',
      scripts: {
        start: 'node dist/server.js',
        'start:pm2': `pm2 start dist/server.js --name ${this.appName}`,
        build: 'tsc',
        'db:migrate': 'node dist/migrate.js',
        'health:check': 'curl http://localhost:${this.port}/health',
        test: 'jest --coverage',
        'test:e2e': 'playwright test'
      },
      dependencies: {
        express: '^4.18.0',
        helmet: '^7.0.0',
        compression: '^1.7.0',
        'cors': '^2.8.0',
        'dotenv': '^16.0.0',
        'pg': '^8.11.0',
        'winston': '^3.11.0',
        'express-rate-limit': '^7.1.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'jest': '^29.5.0',
        '@playwright/test': '^1.40.0',
        'pm2': '^5.3.0'
      },
      engines: {
        node: '>=18.0.0',
        npm: '>=9.0.0'
      }
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });

    // Create server entry point
    const serverTs = `import express from 'express';
import helmet from 'helmet';
import compression from 'compression';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import { config } from 'dotenv';
import { logger } from './utils/logger';

config();

const app = express();
const PORT = process.env.PORT || 3456;

// Security middleware
app.use(helmet());
app.use(cors());
app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api', limiter);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Start server
app.listen(PORT, () => {
  logger.info(\`Server running on port \${PORT}\`);
});
`;

    await fs.ensureDir(path.join(this.deployDir, 'src'));
    await fileAPI.createFile(path.join(this.deployDir, 'src', { type: FileType.TEMPORARY }), serverTs);
  }

  private async createMcpRelease(): Promise<void> {
    const packageJson = {
      name: `${this.appName}-mcp-server`,
      version: '1.0.0',
      description: `${this.appName} - MCP Server`,
      main: 'dist/mcp-server.js',
      scripts: {
        start: 'node dist/mcp-server.js',
        build: 'tsc',
        test: 'jest'
      },
      dependencies: {
        '@modelcontextprotocol/sdk': '^0.5.0',
        'dotenv': '^16.0.0',
        'winston': '^3.11.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'jest': '^29.5.0'
      }
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });

    // Create enhanced MCP server script
    const mcpServerScript = `#!/usr/bin/env node
// MCP Server for ${this.appName}
// Production-ready MCP server with full aidev integration

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { readFile, writeFile, readdir } = require('fs').promises;
const { path } = require('../../../../../../../infra_external-log-lib/src');
const winston = require('winston');

// Configure logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

const AIDEV_ROOT = process.env.AIDEV_ROOT || __dirname;

class AidevMcpServer {
  constructor() {
    this.server = new Server(
      {
        name: '${this.appName}-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  setupHandlers() {
    // List available tools
    this.server.setRequestHandler('tools/list', async () => ({
      tools: [
        {
          name: 'read_task_queue',
          description: 'Read the current task queue',
          inputSchema: {
            type: 'object',
            properties: {},
          },
        },
        {
          name: 'read_feature_backlog',
          description: 'Read the feature backlog',
          inputSchema: {
            type: 'object',
            properties: {},
          },
        },
        {
          name: 'read_llm_rule',
          description: 'Read a specific LLM rule',
          inputSchema: {
            type: 'object',
            properties: {
              ruleName: {
                type: 'string',
                description: 'Name of the rule file (without .md extension)',
              },
            },
            required: ['ruleName'],
          },
        },
        {
          name: 'list_llm_rules',
          description: 'List all available LLM rules',
          inputSchema: {
            type: 'object',
            properties: {},
          },
        },
        {
          name: 'read_claude_config',
          description: 'Read CLAUDE.md configuration',
          inputSchema: {
            type: 'object',
            properties: {},
          },
        },
      ],
    }));

    // Handle tool calls
    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;
      logger.info('Tool called', { tool: name, args });

      try {
        switch (name) {
          case 'read_task_queue':
            return await this.readTaskQueue();
          case 'read_feature_backlog':
            return await this.readFeatureBacklog();
          case 'read_llm_rule':
            return await this.readLlmRule(args.ruleName);
          case 'list_llm_rules':
            return await this.listLlmRules();
          case 'read_claude_config':
            return await this.readClaudeConfig();
          default:
            throw new Error(\`Unknown tool: \${name}\`);
        }
      } catch (error) {
        logger.error('Tool error', { tool: name, error: error.message });
        throw error;
      }
    });
  }

  async readTaskQueue() {
    try {
      const content = await readFile(
        path.join(AIDEV_ROOT, 'TASK_QUEUE.vf.json'),
        'utf-8'
      );
      return {
        content: [
          {
            type: 'text',
            text: content,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Error reading task queue: \${error.message}\`,
          },
        ],
      };
    }
  }

  async readFeatureBacklog() {
    try {
      const content = await readFile(
        path.join(AIDEV_ROOT, 'FEATURE.vf.json'),
        'utf-8'
      );
      return {
        content: [
          {
            type: 'text',
            text: content,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Error reading feature backlog: \${error.message}\`,
          },
        ],
      };
    }
  }

  async readLlmRule(ruleName) {
    try {
      const content = await readFile(
        path.join(AIDEV_ROOT, 'llm_rules', \`\${ruleName}.md\`),
        'utf-8'
      );
      return {
        content: [
          {
            type: 'text',
            text: content,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Error reading LLM rule: \${error.message}\`,
          },
        ],
      };
    }
  }

  async listLlmRules() {
    try {
      const files = await readdir(path.join(AIDEV_ROOT, 'llm_rules'));
      const rules = files
        .filter((file) => file.endsWith('.md'))
        .map((file) => file.replace('.md', ''));
      return {
        content: [
          {
            type: 'text',
            text: \`Available LLM rules:\\n\${rules.join('\\n')}\`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Error listing LLM rules: \${error.message}\`,
          },
        ],
      };
    }
  }

  async readClaudeConfig() {
    try {
      const content = await readFile(
        path.join(AIDEV_ROOT, 'CLAUDE.md'),
        'utf-8'
      );
      return {
        content: [
          {
            type: 'text',
            text: content,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: \`Error reading CLAUDE.md: \${error.message}\`,
          },
        ],
      };
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    logger.info('${this.appName} MCP server started');
    console.error('${this.appName} MCP server running');
  }
}

const server = new AidevMcpServer();
server.run().catch((error) => {
  logger.error('Server startup failed', error);
  console.error(error);
  process.exit(1);
});
`;

    await fs.ensureDir(path.join(this.deployDir, 'src'));
    await fileAPI.createFile(path.join(this.deployDir, 'src', { type: FileType.TEMPORARY }), mcpServerScript);

    // Create MCP setup script for production
    const setupScript = `#!/usr/bin/env bash
# Production MCP setup for ${this.appName}

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "\${BASH_SOURCE[0]}")" && pwd)"

echo "Installing ${this.appName} MCP server for production..."

# Build the server
npm install
npm run build

# Create systemd service for MCP server
sudo tee /etc/systemd/system/${this.appName}-mcp.service > /dev/null << EOF
[Unit]
Description=${this.appName} MCP Server
After=network.target

[Service]
Type=simple
User=mcp
Group=mcp
WorkingDirectory=$SCRIPT_DIR
Environment="NODE_ENV=production"
Environment="AIDEV_ROOT=$SCRIPT_DIR"
ExecStart=/usr/bin/node $SCRIPT_DIR/dist/mcp-server.js
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

# Create user for MCP service
sudo useradd -r -s /bin/false mcp || true

# Set permissions
sudo chown -R mcp:mcp "$SCRIPT_DIR"

# Enable and start service
sudo systemctl daemon-reload
sudo systemctl enable ${this.appName}-mcp
sudo systemctl start ${this.appName}-mcp

echo "✅ ${this.appName} MCP server installed and started"
echo "Check status: sudo systemctl status ${this.appName}-mcp"
`;

    await fileAPI.createFile(path.join(this.deployDir, 'setup-mcp-production.sh'), { type: FileType.TEMPORARY });
    await fs.chmod(path.join(this.deployDir, 'setup-mcp-production.sh'), 0o755);
  }

  private async createCliRelease(): Promise<void> {
    const packageJson = {
      name: `${this.appName}-cli`,
      version: '1.0.0',
      description: `${this.appName} - Command Line Interface`,
      main: 'dist/cli.js',
      bin: {
        [this.appName]: './dist/cli.js'
      },
      scripts: {
        start: 'node dist/cli.js',
        build: 'tsc',
        test: 'jest',
        'build:binary': 'pkg . --output dist/bin/${this.appName}'
      },
      dependencies: {
        'commander': '^11.0.0',
        'chalk': '^5.3.0',
        'inquirer': '^9.2.0',
        'ora': '^7.0.0',
        'dotenv': '^16.0.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'jest': '^29.5.0',
        'pkg': '^5.8.0'
      },
      pkg: {
        targets: ['node18-linux-x64', 'node18-macos-x64', 'node18-win-x64'],
        outputPath: 'dist/bin'
      }
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });
  }

  private async createApiRelease(): Promise<void> {
    const packageJson = {
      name: `${this.appName}-api`,
      version: '1.0.0',
      description: `${this.appName} - REST API`,
      main: 'dist/api.js',
      scripts: {
        start: 'node dist/api.js',
        'start:cluster': 'node dist/cluster.js',
        build: 'tsc',
        test: 'jest',
        'docs:generate': 'swagger-jsdoc -d swaggerDef.js -o ./docs/swagger.json'
      },
      dependencies: {
        'express': '^4.18.0',
        '@fastify/fastify': '^4.24.0',
        'helmet': '^7.0.0',
        'joi': '^17.11.0',
        'swagger-ui-express': '^5.0.0',
        'winston': '^3.11.0',
        'dotenv': '^16.0.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'jest': '^29.5.0',
        'swagger-jsdoc': '^6.2.0'
      }
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });
  }

  private async createLibraryRelease(): Promise<void> {
    const packageJson = {
      name: `@${this.appName}/core`,
      version: '1.0.0',
      description: `${this.appName} - Core Library`,
      main: 'dist/index.js',
      types: 'dist/index.d.ts',
      files: ['dist', 'README.md', 'LICENSE'],
      scripts: {
        build: 'tsc',
        'build:watch': 'tsc --watch',
        test: 'jest',
        'test:watch': 'jest --watch',
        lint: 'eslint src/**/*.ts',
        prepublishOnly: 'npm test && npm run build'
      },
      peerDependencies: {
        'typescript': '>=4.0.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'jest': '^29.5.0',
        'eslint': '^8.0.0',
        '@typescript-eslint/eslint-plugin': '^6.0.0',
        '@typescript-eslint/parser': '^6.0.0'
      },
      publishConfig: {
        access: 'public',
        registry: 'https://registry.npmjs.org/'
      }
    };

    await fs.writeJson(path.join(this.deployDir, 'package.json'), packageJson, { spaces: 2 });

    // Create library entry point
    const indexTs = `export * from './core';
export * from './types';
export * from './utils';

export const VERSION = '1.0.0';
`;

    await fs.ensureDir(path.join(this.deployDir, 'src'));
    await fileAPI.createFile(path.join(this.deployDir, 'src', { type: FileType.TEMPORARY }), indexTs);
  }

  private async createDockerfile(): Promise<void> {
    const dockerfile = `FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM node:18-alpine

WORKDIR /app

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Copy built application
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# Switch to non-root user
USER nodejs

EXPOSE ${this.port}

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/server.js"]
`;

    await fileAPI.createFile(path.join(this.deployDir, 'Dockerfile'), { type: FileType.TEMPORARY });
  }

  private async createDockerCompose(): Promise<void> {
    const dockerCompose = `version: '3.8'

services:
  app:
    build: .
    container_name: ${this.appName}
    restart: unless-stopped
    ports:
      - "${this.port}:${this.port}"
    environment:
      - NODE_ENV=production
      - PORT=${this.port}
    env_file:
      - .env
    depends_on:
      - postgres
    networks:
      - app-network

  postgres:
    image: postgres:15-alpine
    container_name: ${this.appName}-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${this.dbUser}
      POSTGRES_PASSWORD: ${this.dbPassword}
      POSTGRES_DB: ${this.dbName}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    container_name: ${this.appName}-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - app-network

volumes:
  postgres-data:

networks:
  app-network:
    driver: bridge
`;

    await fileAPI.createFile(path.join(this.deployDir, 'docker-compose.yml'), { type: FileType.TEMPORARY });
  }

  private async createSystemdService(): Promise<void> {
    const service = `[Unit]
Description=${this.appName} - ${this.releaseType}
After=network.target postgresql.service

[Service]
Type=simple
User=nodejs
Group=nodejs
WorkingDirectory=/opt/${this.appName}
Environment="NODE_ENV=production"
Environment="PORT=${this.port}"
ExecStart=/usr/bin/node /opt/${this.appName}/dist/server.js
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/${this.appName}/logs /opt/${this.appName}/data

[Install]
WantedBy=multi-user.target
`;

    await fileAPI.createFile(path.join(this.deployDir, `${this.appName}.service`), { type: FileType.TEMPORARY });
  }

  private async createNginxConfig(): Promise<void> {
    const nginxConfig = `upstream ${this.appName} {
    server localhost:${this.port};
}

server {
    listen 80;
    server_name ${this.domain || 'localhost'};
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ${this.domain || 'localhost'};

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${this.appName};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    location /health {
        access_log off;
        proxy_pass http://${this.appName}/health;
    }
}
`;

    await fileAPI.createFile(path.join(this.deployDir, 'nginx.conf'), { type: FileType.TEMPORARY });
  }

  private async saveDbPassword(): Promise<void> {
    const secretsDir = path.join(this.deployDir, 'config', 'secrets');
    await fs.ensureDir(secretsDir);
    await fileAPI.createFile(path.join(secretsDir, 'db_password.txt'), { type: FileType.TEMPORARY });
    await fs.chmod(path.join(secretsDir, 'db_password.txt'), 0o600);
  }

  private async deployClaudeConfig(): Promise<void> {
    const projectRoot = path.join(__dirname, '../../../../..');
    
    // Copy CLAUDE.md if it exists
    const claudeMdPath = path.join(projectRoot, 'CLAUDE.md');
    if (await fs.pathExists(claudeMdPath)) {
      await fs.copy(claudeMdPath, path.join(this.deployDir, 'CLAUDE.md'));
      console.log(chalk.green('   ✓ Deployed CLAUDE.md'));
    }
    
    // Copy llm_rules directory if it exists
    const llmRulesPath = path.join(projectRoot, 'llm_rules');
    if (await fs.pathExists(llmRulesPath)) {
      await fs.copy(llmRulesPath, path.join(this.deployDir, 'llm_rules'));
      console.log(chalk.green('   ✓ Deployed llm_rules/'));
    }
    
    // For MCP release type, create full MCP configuration
    if (this.releaseType === 'mcp' && this.mode === 'vf') {
      const mcpConfigDir = path.join(this.deployDir, 'config', 'mcp');
      await fs.ensureDir(mcpConfigDir);
      
      const mcpAgentConfig = {
        agents: {
          architect: {
            description: "System architecture and design",
            capabilities: ["design", "architecture", "patterns"],
            tools: ["filesystem", "search", "edit"]
          },
          developer: {
            description: "Implementation and coding",
            capabilities: ["coding", "testing", "debugging"],
            tools: ["filesystem", "edit", "bash", "git"]
          },
          tester: {
            description: "Testing and quality assurance",
            capabilities: ["testing", "coverage", "e2e"],
            tools: ["filesystem", "bash", "playwright"]
          },
          gui: {
            description: "GUI design and implementation",
            capabilities: ["ui", "ux", "design"],
            tools: ["filesystem", "edit", "preview"]
          }
        }
      };
      
      await fs.writeJson(path.join(mcpConfigDir, 'mcp-agent.json'), mcpAgentConfig, { spaces: 2 });
    }
  }

  printSuccessMessage(): void {
    console.log(chalk.green('\n' + '='.repeat(50)));
    console.log(chalk.green(`✅ Release setup completed successfully! (${this.mode.toUpperCase()} Mode)`));
    console.log(chalk.green(`📦 Release Type: ${this.releaseType}`));
    console.log(chalk.green('\n📍 Release location: ' + this.deployDir));
    console.log(chalk.green(`🌐 Port: ${this.port}`));
    console.log(chalk.green(`🔐 Domain: ${this.domain || 'localhost'}`));
    
    console.log(chalk.yellow('\n🚀 Deployment Instructions:'));
    
    if (this.releaseType === 'web-server' || this.releaseType === 'api') {
      console.log(chalk.yellow('\n  Using Docker:'));
      console.log(chalk.yellow(`    cd ${this.deployDir}`));
      console.log(chalk.yellow('    docker-compose up -d'));
      
      console.log(chalk.yellow('\n  Using systemd:'));
      console.log(chalk.yellow(`    sudo cp ${this.appName}.service /etc/systemd/system/`));
      console.log(chalk.yellow(`    sudo systemctl enable ${this.appName}`));
      console.log(chalk.yellow(`    sudo systemctl start ${this.appName}`));
    } else if (this.releaseType === 'mcp') {
      console.log(chalk.yellow('\n  For production:'));
      console.log(chalk.yellow(`    cd ${this.deployDir}`));
      console.log(chalk.yellow('    ./setup-mcp-production.sh'));
      console.log(chalk.yellow('\n  For development:'));
      console.log(chalk.yellow('    npm install'));
      console.log(chalk.yellow('    npm run build'));
      console.log(chalk.yellow('    npm start'));
    } else if (this.releaseType === 'cli') {
      console.log(chalk.yellow('    npm run build:binary'));
      console.log(chalk.yellow(`    ./dist/bin/${this.appName}`));
    } else if (this.releaseType === 'library') {
      console.log(chalk.yellow('    npm run build'));
      console.log(chalk.yellow('    npm publish'));
    }
    
    console.log(chalk.red('\n⚠️  Important Security Notes:'));
    console.log(chalk.red(`   - Database password saved in: config/secrets/db_password.txt`));
    console.log(chalk.red('   - Update SSL certificates in nginx.conf'));
    console.log(chalk.red('   - Review and update security settings before deployment'));
    
    if (this.mode === 'vf') {
      console.log(chalk.cyan('\n🔌 VF Mode Configuration:'));
      console.log(chalk.cyan('   - Task Queue: TASK_QUEUE.vf.json'));
      console.log(chalk.cyan('   - MCP Config: config/mcp-agent.json'));
      console.log(chalk.cyan('   - CLAUDE.md and llm_rules/ deployed'));
    }
  }
}